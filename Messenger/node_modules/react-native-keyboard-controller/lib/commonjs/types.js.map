{"version":3,"names":[],"sources":["types.ts"],"sourcesContent":["import type {\n  EmitterSubscription,\n  NativeSyntheticEvent,\n  ViewProps,\n} from \"react-native\";\n\n// DirectEventHandler events declaration\nexport type NativeEvent = {\n  progress: number;\n  height: number;\n  duration: number;\n  target: number;\n};\nexport type FocusedInputLayoutChangedEvent = {\n  target: number;\n  parentScrollViewTarget: number;\n  layout: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    absoluteX: number;\n    absoluteY: number;\n  };\n};\nexport type FocusedInputTextChangedEvent = {\n  text: string;\n};\nexport type EventWithName<T> = {\n  eventName: string;\n} & T;\n\n// native View/Module declarations\nexport type KeyboardControllerProps = {\n  // callback props\n  onKeyboardMoveStart?: (\n    e: NativeSyntheticEvent<EventWithName<NativeEvent>>,\n  ) => void;\n  onKeyboardMove?: (\n    e: NativeSyntheticEvent<EventWithName<NativeEvent>>,\n  ) => void;\n  onKeyboardMoveEnd?: (\n    e: NativeSyntheticEvent<EventWithName<NativeEvent>>,\n  ) => void;\n  onKeyboardMoveInteractive?: (\n    e: NativeSyntheticEvent<EventWithName<NativeEvent>>,\n  ) => void;\n  onFocusedInputLayoutChanged?: (\n    e: NativeSyntheticEvent<EventWithName<FocusedInputLayoutChangedEvent>>,\n  ) => void;\n  onFocusedInputTextChanged?: (\n    e: NativeSyntheticEvent<EventWithName<FocusedInputTextChangedEvent>>,\n  ) => void;\n  // fake props used to activate reanimated bindings\n  onKeyboardMoveReanimated?: (\n    e: NativeSyntheticEvent<EventWithName<NativeEvent>>,\n  ) => void;\n  onFocusedInputLayoutChangedReanimated?: (\n    e: NativeSyntheticEvent<EventWithName<FocusedInputLayoutChangedEvent>>,\n  ) => void;\n  onFocusedInputTextChangedReanimated?: (\n    e: NativeSyntheticEvent<EventWithName<FocusedInputTextChangedEvent>>,\n  ) => void;\n  // props\n  statusBarTranslucent?: boolean;\n  navigationBarTranslucent?: boolean;\n  enabled?: boolean;\n} & ViewProps;\n\nexport type KeyboardGestureAreaProps = {\n  interpolator: \"ios\" | \"linear\";\n  /**\n   * Whether to allow to show a keyboard from dismissed state by swipe up.\n   * Default to `false`.\n   */\n  showOnSwipeUp?: boolean;\n  /**\n   * Whether to allow to control a keyboard by gestures. The strategy how\n   * it should be controlled is determined by `interpolator` property.\n   * Defaults to `true`.\n   */\n  enableSwipeToDismiss?: boolean;\n} & ViewProps;\n\nexport type Direction = \"next\" | \"prev\" | \"current\";\nexport type KeyboardControllerModule = {\n  // android only\n  setDefaultMode: () => void;\n  setInputMode: (mode: number) => void;\n  // all platforms\n  dismiss: () => void;\n  setFocusTo: (direction: Direction) => void;\n  // native event module stuff\n  addListener: (eventName: string) => void;\n  removeListeners: (count: number) => void;\n};\n\n// Event module declarations\nexport type KeyboardControllerEvents =\n  | \"keyboardWillShow\"\n  | \"keyboardDidShow\"\n  | \"keyboardWillHide\"\n  | \"keyboardDidHide\";\nexport type KeyboardEventData = {\n  height: number;\n  duration: number;\n  timestamp: number;\n  target: number;\n};\nexport type KeyboardEventsModule = {\n  addListener: (\n    name: KeyboardControllerEvents,\n    cb: (e: KeyboardEventData) => void,\n  ) => EmitterSubscription;\n};\nexport type FocusedInputAvailableEvents = \"focusDidSet\";\nexport type FocusedInputEventData = {\n  current: number;\n  count: number;\n};\nexport type FocusedInputEventsModule = {\n  addListener: (\n    name: FocusedInputAvailableEvents,\n    cb: (e: FocusedInputEventData) => void,\n  ) => EmitterSubscription;\n};\n\n// reanimated hook declaration\nexport type KeyboardHandlerHook<TContext, Event> = (\n  handlers: {\n    onKeyboardMoveStart?: (e: NativeEvent, context: TContext) => void;\n    onKeyboardMove?: (e: NativeEvent, context: TContext) => void;\n    onKeyboardMoveEnd?: (e: NativeEvent, context: TContext) => void;\n    onKeyboardMoveInteractive?: (e: NativeEvent, context: TContext) => void;\n  },\n  dependencies?: unknown[],\n) => (e: NativeSyntheticEvent<Event>) => void;\nexport type FocusedInputLayoutHandlerHook<TContext, Event> = (\n  handlers: {\n    onFocusedInputLayoutChanged?: (\n      e: FocusedInputLayoutChangedEvent,\n      context: TContext,\n    ) => void;\n  },\n  dependencies?: unknown[],\n) => (e: NativeSyntheticEvent<Event>) => void;\nexport type FocusedInputTextHandlerHook<TContext, Event> = (\n  handlers: {\n    onFocusedInputTextChanged?: (\n      e: FocusedInputTextChangedEvent,\n      context: TContext,\n    ) => void;\n  },\n  dependencies?: unknown[],\n) => (e: NativeSyntheticEvent<Event>) => void;\n\n// package types\nexport type Handlers<T> = Record<string, T | undefined>;\nexport type KeyboardHandler = Partial<{\n  onStart: (e: NativeEvent) => void;\n  onMove: (e: NativeEvent) => void;\n  onEnd: (e: NativeEvent) => void;\n  onInteractive: (e: NativeEvent) => void;\n}>;\nexport type KeyboardHandlers = Handlers<KeyboardHandler>;\nexport type FocusedInputHandler = Partial<{\n  onChangeText: (e: FocusedInputTextChangedEvent) => void;\n}>;\nexport type FocusedInputHandlers = Handlers<FocusedInputHandler>;\n"],"mappings":"","ignoreList":[]}