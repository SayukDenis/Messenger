{"version":3,"names":["_reactNative","require","_reactNativeReanimated","_reactNativeKeyboardController","useKeyboardInterpolation","nextKeyboardHeight","useSharedValue","prevKeyboardHeight","lastInterpolation","shouldUseInternalInterpolation","interpolate","keyboardPosition","output","Platform","OS","interpolateREA","value","useKeyboardHandler","onStart","e","keyboardWillBeHidden","height","onEnd","_default","exports","default"],"sources":["useKeyboardInterpolation.ts"],"sourcesContent":["import { Platform } from \"react-native\";\nimport {\n  interpolate as interpolateREA,\n  useSharedValue,\n} from \"react-native-reanimated\";\n\nimport { useKeyboardHandler } from \"react-native-keyboard-controller\";\n\ntype KeyboardInterpolationOutput = [number, number];\n\n/**\n * Hook that can be used for interpolation keyboard movement. The main concern is the thing\n * when keyboard is opened and gets resized on Android. Let's say we are interpolating from\n * closed to open [0, 200] and we want to interpolate it to [0, 230] (to achieve nice parallax effect).\n * Then let's say keyboard changes its height to 220 (and we want to interpolate the value to 250, +30\n * to keyboard height). If we interpolate based on `progress` value, then we will have a jump on first frame:\n * the last interpolated position was 230, now we will interpolate to 250, but first frame will be calculated\n * as 200 / 220 * 250 = 227 (and last interpolated position was 230) so we will have a jump.\n *\n * This hook handles it, and when keyboard changes its size it does an interpolation as:\n * [200, 220] -> [230, 250], i. e. we preserve last interpolated value and use it as initial value for interpolation\n * and because of that we will not have a jump and animation will start from the last frame and will be smooth.\n *\n * @see https://github.com/kirillzyusko/react-native-keyboard-controller/issues/315\n */\nconst useKeyboardInterpolation = () => {\n  // keyboard heights\n  const nextKeyboardHeight = useSharedValue(0);\n  const prevKeyboardHeight = useSharedValue(0);\n  // save latest interpolated position\n  const lastInterpolation = useSharedValue(0);\n  // boolean flag indicating which output range should be used\n  const shouldUseInternalInterpolation = useSharedValue(false);\n\n  const interpolate = (\n    keyboardPosition: number,\n    output: KeyboardInterpolationOutput,\n  ) => {\n    \"worklet\";\n\n    // on iOS it's safe to interpolate between 0 and `fullKeyboardSize` because when\n    // keyboard resized we will not have intermediate values and transition will be instant\n    // see: https://github.com/kirillzyusko/react-native-keyboard-controller/issues/327\n    if (Platform.OS === \"ios\") {\n      return interpolateREA(\n        keyboardPosition,\n        [0, nextKeyboardHeight.value],\n        output,\n      );\n    }\n\n    lastInterpolation.value = interpolateREA(\n      keyboardPosition,\n      [prevKeyboardHeight.value, nextKeyboardHeight.value],\n      shouldUseInternalInterpolation.value\n        ? [lastInterpolation.value, output[1]]\n        : output,\n    );\n\n    return lastInterpolation.value;\n  };\n\n  useKeyboardHandler(\n    {\n      onStart: (e) => {\n        \"worklet\";\n\n        const keyboardWillBeHidden = e.height === 0;\n\n        // keyboard will be hidden\n        if (keyboardWillBeHidden) {\n          shouldUseInternalInterpolation.value = false;\n          prevKeyboardHeight.value = 0;\n        }\n\n        // keyboard will change its size\n        if (\n          // keyboard is shown on screen\n          nextKeyboardHeight.value !== 0 &&\n          // it really changes size (handles iOS case when after interactive keyboard gets shown again)\n          nextKeyboardHeight.value !== e.height &&\n          // keyboard is not hiding\n          !keyboardWillBeHidden\n        ) {\n          prevKeyboardHeight.value = nextKeyboardHeight.value;\n          shouldUseInternalInterpolation.value = true;\n        }\n\n        // keyboard will show or change size\n        if (!keyboardWillBeHidden) {\n          nextKeyboardHeight.value = e.height;\n        }\n      },\n      onEnd: (e) => {\n        \"worklet\";\n\n        // handles case show -> resize -> hide -> show\n        // here we reset value to 0 when keyboard is hidden\n        nextKeyboardHeight.value = e.height;\n      },\n    },\n    [],\n  );\n\n  return { interpolate };\n};\n\nexport default useKeyboardInterpolation;\n"],"mappings":";;;;;;AAAA,IAAAA,YAAA,GAAAC,OAAA;AACA,IAAAC,sBAAA,GAAAD,OAAA;AAKA,IAAAE,8BAAA,GAAAF,OAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMG,wBAAwB,GAAGA,CAAA,KAAM;EACrC;EACA,MAAMC,kBAAkB,GAAG,IAAAC,qCAAc,EAAC,CAAC,CAAC;EAC5C,MAAMC,kBAAkB,GAAG,IAAAD,qCAAc,EAAC,CAAC,CAAC;EAC5C;EACA,MAAME,iBAAiB,GAAG,IAAAF,qCAAc,EAAC,CAAC,CAAC;EAC3C;EACA,MAAMG,8BAA8B,GAAG,IAAAH,qCAAc,EAAC,KAAK,CAAC;EAE5D,MAAMI,WAAW,GAAGA,CAClBC,gBAAwB,EACxBC,MAAmC,KAChC;IACH,SAAS;;IAET;IACA;IACA;IACA,IAAIC,qBAAQ,CAACC,EAAE,KAAK,KAAK,EAAE;MACzB,OAAO,IAAAC,kCAAc,EACnBJ,gBAAgB,EAChB,CAAC,CAAC,EAAEN,kBAAkB,CAACW,KAAK,CAAC,EAC7BJ,MACF,CAAC;IACH;IAEAJ,iBAAiB,CAACQ,KAAK,GAAG,IAAAD,kCAAc,EACtCJ,gBAAgB,EAChB,CAACJ,kBAAkB,CAACS,KAAK,EAAEX,kBAAkB,CAACW,KAAK,CAAC,EACpDP,8BAA8B,CAACO,KAAK,GAChC,CAACR,iBAAiB,CAACQ,KAAK,EAAEJ,MAAM,CAAC,CAAC,CAAC,CAAC,GACpCA,MACN,CAAC;IAED,OAAOJ,iBAAiB,CAACQ,KAAK;EAChC,CAAC;EAED,IAAAC,iDAAkB,EAChB;IACEC,OAAO,EAAGC,CAAC,IAAK;MACd,SAAS;;MAET,MAAMC,oBAAoB,GAAGD,CAAC,CAACE,MAAM,KAAK,CAAC;;MAE3C;MACA,IAAID,oBAAoB,EAAE;QACxBX,8BAA8B,CAACO,KAAK,GAAG,KAAK;QAC5CT,kBAAkB,CAACS,KAAK,GAAG,CAAC;MAC9B;;MAEA;MACA;MACE;MACAX,kBAAkB,CAACW,KAAK,KAAK,CAAC;MAC9B;MACAX,kBAAkB,CAACW,KAAK,KAAKG,CAAC,CAACE,MAAM;MACrC;MACA,CAACD,oBAAoB,EACrB;QACAb,kBAAkB,CAACS,KAAK,GAAGX,kBAAkB,CAACW,KAAK;QACnDP,8BAA8B,CAACO,KAAK,GAAG,IAAI;MAC7C;;MAEA;MACA,IAAI,CAACI,oBAAoB,EAAE;QACzBf,kBAAkB,CAACW,KAAK,GAAGG,CAAC,CAACE,MAAM;MACrC;IACF,CAAC;IACDC,KAAK,EAAGH,CAAC,IAAK;MACZ,SAAS;;MAET;MACA;MACAd,kBAAkB,CAACW,KAAK,GAAGG,CAAC,CAACE,MAAM;IACrC;EACF,CAAC,EACD,EACF,CAAC;EAED,OAAO;IAAEX;EAAY,CAAC;AACxB,CAAC;AAAC,IAAAa,QAAA,GAEanB,wBAAwB;AAAAoB,OAAA,CAAAC,OAAA,GAAAF,QAAA"}