"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _reactNativeReanimated = _interopRequireWildcard(require("react-native-reanimated"));
var _reactNativeKeyboardController = require("react-native-keyboard-controller");
var _useSmoothKeyboardHandler = require("./useSmoothKeyboardHandler");
var _utils = require("./utils");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
/*
 * Everything begins from `onStart` handler. This handler is called every time,
 * when keyboard changes its size or when focused `TextInput` was changed. In
 * this handler we are calculating/memoizing values which later will be used
 * during layout movement. For that we calculate:
 * - layout of focused field (`layout`) - to understand whether there will be overlap
 * - initial keyboard size (`initialKeyboardSize`) - used in scroll interpolation
 * - future keyboard height (`keyboardHeight`) - used in scroll interpolation
 * - current scroll position (`scrollPosition`) - used to scroll from this point
 *
 * Once we've calculated all necessary variables - we can actually start to use them.
 * It happens in `onMove` handler - this function simply calls `maybeScroll` with
 * current keyboard frame height. This functions makes the smooth transition.
 *
 * When the transition has finished we go to `onEnd` handler. In this handler
 * we verify, that the current field is not overlapped within a keyboard frame.
 * For full `onStart`/`onMove`/`onEnd` flow it may look like a redundant thing,
 * however there could be some cases, when `onMove` is not called:
 * - on iOS when TextInput was changed - keyboard transition is instant
 * - on Android when TextInput was changed and keyboard size wasn't changed
 * So `onEnd` handler handle the case, when `onMove` wasn't triggered.
 *
 * ====================================================================================================================+
 * -----------------------------------------------------Flow chart-----------------------------------------------------+
 * ====================================================================================================================+
 *
 * +============================+       +============================+        +==================================+
 * +  User Press on TextInput   +   =>  +  Keyboard starts showing   +   =>   + As keyboard moves frame by frame +  =>
 * +                            +       +       (run `onStart`)      +        +    `onMove` is getting called    +
 * +============================+       +============================+        +==================================+
 *
 *
 * +============================+       +============================+        +=====================================+
 * + Keyboard is shown and we   +   =>  +    User moved focus to     +   =>   + Only `onStart`/`onEnd` maybe called +
 * +    call `onEnd` handler    +       +     another `TextInput`    +        +    (without involving `onMove`)     +
 * +============================+       +============================+        +=====================================+
 *
 */
const KeyboardAwareScrollView = _ref => {
  let {
    children,
    bottomOffset = 0,
    disableScrollOnKeyboardHide = false,
    ...rest
  } = _ref;
  const scrollViewAnimatedRef = (0, _reactNativeReanimated.useAnimatedRef)();
  const scrollPosition = (0, _reactNativeReanimated.useSharedValue)(0);
  const position = (0, _reactNativeReanimated.useSharedValue)(0);
  const currentKeyboardFrameHeight = (0, _reactNativeReanimated.useSharedValue)(0);
  const keyboardHeight = (0, _reactNativeReanimated.useSharedValue)(0);
  const keyboardWillAppear = (0, _reactNativeReanimated.useSharedValue)(false);
  const tag = (0, _reactNativeReanimated.useSharedValue)(-1);
  const initialKeyboardSize = (0, _reactNativeReanimated.useSharedValue)(0);
  const scrollBeforeKeyboardMovement = (0, _reactNativeReanimated.useSharedValue)(0);
  const {
    input
  } = (0, _reactNativeKeyboardController.useReanimatedFocusedInput)();
  const layout = (0, _reactNativeReanimated.useSharedValue)(null);
  const {
    height
  } = (0, _reactNative.useWindowDimensions)();
  const onScroll = (0, _reactNativeReanimated.useAnimatedScrollHandler)({
    onScroll: e => {
      position.value = e.contentOffset.y;
    }
  }, []);

  /**
   * Function that will scroll a ScrollView as keyboard gets moving
   */
  const maybeScroll = (0, _react.useCallback)(function (e) {
    "worklet";

    var _layout$value, _layout$value2;
    let animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    const visibleRect = height - keyboardHeight.value;
    const absoluteY = ((_layout$value = layout.value) === null || _layout$value === void 0 ? void 0 : _layout$value.layout.absoluteY) || 0;
    const inputHeight = ((_layout$value2 = layout.value) === null || _layout$value2 === void 0 ? void 0 : _layout$value2.layout.height) || 0;
    const point = absoluteY + inputHeight;
    if (visibleRect - point <= bottomOffset) {
      const interpolatedScrollTo = (0, _reactNativeReanimated.interpolate)(e, [initialKeyboardSize.value, keyboardHeight.value], [0, keyboardHeight.value - (height - point) + bottomOffset]);
      const targetScrollY = Math.max(interpolatedScrollTo, 0) + scrollPosition.value;
      (0, _reactNativeReanimated.scrollTo)(scrollViewAnimatedRef, 0, targetScrollY, animated);
      return interpolatedScrollTo;
    }
    if (absoluteY < 0) {
      const positionOnScreen = visibleRect - inputHeight - bottomOffset;
      const topOfScreen = scrollPosition.value + absoluteY;
      (0, _reactNativeReanimated.scrollTo)(scrollViewAnimatedRef, 0, topOfScreen - positionOnScreen, animated);
    }
    return 0;
  }, [bottomOffset]);
  const onChangeText = (0, _react.useCallback)(() => {
    "worklet";

    // if typing a text caused layout shift, then we need to ignore this handler
    // because this event will be handled in `useAnimatedReaction` below
    var _layout$value3, _input$value;
    if (((_layout$value3 = layout.value) === null || _layout$value3 === void 0 ? void 0 : _layout$value3.layout.height) !== ((_input$value = input.value) === null || _input$value === void 0 ? void 0 : _input$value.layout.height)) {
      return;
    }
    const prevScrollPosition = scrollPosition.value;
    const prevLayout = layout.value;
    scrollPosition.value = position.value;
    layout.value = input.value;
    maybeScroll(keyboardHeight.value, true);
    scrollPosition.value = prevScrollPosition;
    layout.value = prevLayout;
  }, [maybeScroll]);
  const onChangeTextHandler = (0, _react.useMemo)(() => (0, _utils.debounce)(onChangeText, 200), [onChangeText]);
  (0, _reactNativeKeyboardController.useFocusedInputHandler)({
    onChangeText: onChangeTextHandler
  }, [onChangeTextHandler]);
  (0, _useSmoothKeyboardHandler.useSmoothKeyboardHandler)({
    onStart: e => {
      "worklet";

      const keyboardWillChangeSize = keyboardHeight.value !== e.height && e.height > 0;
      keyboardWillAppear.value = e.height > 0 && keyboardHeight.value === 0;
      const keyboardWillHide = e.height === 0;
      const focusWasChanged = tag.value !== e.target && e.target !== -1 || keyboardWillChangeSize;
      if (keyboardWillChangeSize) {
        initialKeyboardSize.value = keyboardHeight.value;
      }
      if (keyboardWillHide) {
        // on back transition need to interpolate as [0, keyboardHeight]
        initialKeyboardSize.value = 0;
        scrollPosition.value = scrollBeforeKeyboardMovement.value;
      }
      if (keyboardWillAppear.value || keyboardWillChangeSize || focusWasChanged) {
        // persist scroll value
        scrollPosition.value = position.value;
        // just persist height - later will be used in interpolation
        keyboardHeight.value = e.height;
      }

      // focus was changed
      if (focusWasChanged) {
        tag.value = e.target;

        // save position of focused text input when keyboard starts to move
        layout.value = input.value;
        // save current scroll position - when keyboard will hide we'll reuse
        // this value to achieve smooth hide effect
        scrollBeforeKeyboardMovement.value = position.value;
      }
      if (focusWasChanged && !keyboardWillAppear.value) {
        // update position on scroll value, so `onEnd` handler
        // will pick up correct values
        position.value += maybeScroll(e.height, true);
      }
    },
    onMove: e => {
      "worklet";

      currentKeyboardFrameHeight.value = e.height;

      // if the user has set disableScrollOnKeyboardHide, only auto-scroll when the keyboard opens
      if (!disableScrollOnKeyboardHide || keyboardWillAppear.value) {
        maybeScroll(e.height);
      }
    },
    onEnd: e => {
      "worklet";

      keyboardHeight.value = e.height;
      scrollPosition.value = position.value;
    }
  }, [height, maybeScroll, disableScrollOnKeyboardHide]);
  (0, _reactNativeReanimated.useAnimatedReaction)(() => input.value, (current, previous) => {
    if ((current === null || current === void 0 ? void 0 : current.target) === (previous === null || previous === void 0 ? void 0 : previous.target) && (current === null || current === void 0 ? void 0 : current.layout.height) !== (previous === null || previous === void 0 ? void 0 : previous.layout.height)) {
      const prevLayout = layout.value;
      layout.value = input.value;
      scrollPosition.value += maybeScroll(keyboardHeight.value, true);
      layout.value = prevLayout;
    }
  }, []);
  const view = (0, _reactNativeReanimated.useAnimatedStyle)(() => ({
    paddingBottom: currentKeyboardFrameHeight.value
  }), []);
  return /*#__PURE__*/_react.default.createElement(_reactNativeReanimated.default.ScrollView, _extends({
    ref: scrollViewAnimatedRef
  }, rest, {
    // @ts-expect-error `onScrollReanimated` is a fake prop needed for reanimated to intercept scroll events
    onScrollReanimated: onScroll,
    scrollEventThrottle: 16
  }), children, /*#__PURE__*/_react.default.createElement(_reactNativeReanimated.default.View, {
    style: view
  }));
};
var _default = KeyboardAwareScrollView;
exports.default = _default;
//# sourceMappingURL=index.js.map