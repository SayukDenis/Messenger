{"version":3,"names":["Platform","interpolate","interpolateREA","useSharedValue","useKeyboardHandler","useKeyboardInterpolation","nextKeyboardHeight","prevKeyboardHeight","lastInterpolation","shouldUseInternalInterpolation","keyboardPosition","output","OS","value","onStart","e","keyboardWillBeHidden","height","onEnd"],"sources":["useKeyboardInterpolation.ts"],"sourcesContent":["import { Platform } from \"react-native\";\nimport {\n  interpolate as interpolateREA,\n  useSharedValue,\n} from \"react-native-reanimated\";\n\nimport { useKeyboardHandler } from \"react-native-keyboard-controller\";\n\ntype KeyboardInterpolationOutput = [number, number];\n\n/**\n * Hook that can be used for interpolation keyboard movement. The main concern is the thing\n * when keyboard is opened and gets resized on Android. Let's say we are interpolating from\n * closed to open [0, 200] and we want to interpolate it to [0, 230] (to achieve nice parallax effect).\n * Then let's say keyboard changes its height to 220 (and we want to interpolate the value to 250, +30\n * to keyboard height). If we interpolate based on `progress` value, then we will have a jump on first frame:\n * the last interpolated position was 230, now we will interpolate to 250, but first frame will be calculated\n * as 200 / 220 * 250 = 227 (and last interpolated position was 230) so we will have a jump.\n *\n * This hook handles it, and when keyboard changes its size it does an interpolation as:\n * [200, 220] -> [230, 250], i. e. we preserve last interpolated value and use it as initial value for interpolation\n * and because of that we will not have a jump and animation will start from the last frame and will be smooth.\n *\n * @see https://github.com/kirillzyusko/react-native-keyboard-controller/issues/315\n */\nconst useKeyboardInterpolation = () => {\n  // keyboard heights\n  const nextKeyboardHeight = useSharedValue(0);\n  const prevKeyboardHeight = useSharedValue(0);\n  // save latest interpolated position\n  const lastInterpolation = useSharedValue(0);\n  // boolean flag indicating which output range should be used\n  const shouldUseInternalInterpolation = useSharedValue(false);\n\n  const interpolate = (\n    keyboardPosition: number,\n    output: KeyboardInterpolationOutput,\n  ) => {\n    \"worklet\";\n\n    // on iOS it's safe to interpolate between 0 and `fullKeyboardSize` because when\n    // keyboard resized we will not have intermediate values and transition will be instant\n    // see: https://github.com/kirillzyusko/react-native-keyboard-controller/issues/327\n    if (Platform.OS === \"ios\") {\n      return interpolateREA(\n        keyboardPosition,\n        [0, nextKeyboardHeight.value],\n        output,\n      );\n    }\n\n    lastInterpolation.value = interpolateREA(\n      keyboardPosition,\n      [prevKeyboardHeight.value, nextKeyboardHeight.value],\n      shouldUseInternalInterpolation.value\n        ? [lastInterpolation.value, output[1]]\n        : output,\n    );\n\n    return lastInterpolation.value;\n  };\n\n  useKeyboardHandler(\n    {\n      onStart: (e) => {\n        \"worklet\";\n\n        const keyboardWillBeHidden = e.height === 0;\n\n        // keyboard will be hidden\n        if (keyboardWillBeHidden) {\n          shouldUseInternalInterpolation.value = false;\n          prevKeyboardHeight.value = 0;\n        }\n\n        // keyboard will change its size\n        if (\n          // keyboard is shown on screen\n          nextKeyboardHeight.value !== 0 &&\n          // it really changes size (handles iOS case when after interactive keyboard gets shown again)\n          nextKeyboardHeight.value !== e.height &&\n          // keyboard is not hiding\n          !keyboardWillBeHidden\n        ) {\n          prevKeyboardHeight.value = nextKeyboardHeight.value;\n          shouldUseInternalInterpolation.value = true;\n        }\n\n        // keyboard will show or change size\n        if (!keyboardWillBeHidden) {\n          nextKeyboardHeight.value = e.height;\n        }\n      },\n      onEnd: (e) => {\n        \"worklet\";\n\n        // handles case show -> resize -> hide -> show\n        // here we reset value to 0 when keyboard is hidden\n        nextKeyboardHeight.value = e.height;\n      },\n    },\n    [],\n  );\n\n  return { interpolate };\n};\n\nexport default useKeyboardInterpolation;\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,cAAc;AACvC,SACEC,WAAW,IAAIC,cAAc,EAC7BC,cAAc,QACT,yBAAyB;AAEhC,SAASC,kBAAkB,QAAQ,kCAAkC;AAIrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,wBAAwB,GAAGA,CAAA,KAAM;EACrC;EACA,MAAMC,kBAAkB,GAAGH,cAAc,CAAC,CAAC,CAAC;EAC5C,MAAMI,kBAAkB,GAAGJ,cAAc,CAAC,CAAC,CAAC;EAC5C;EACA,MAAMK,iBAAiB,GAAGL,cAAc,CAAC,CAAC,CAAC;EAC3C;EACA,MAAMM,8BAA8B,GAAGN,cAAc,CAAC,KAAK,CAAC;EAE5D,MAAMF,WAAW,GAAGA,CAClBS,gBAAwB,EACxBC,MAAmC,KAChC;IACH,SAAS;;IAET;IACA;IACA;IACA,IAAIX,QAAQ,CAACY,EAAE,KAAK,KAAK,EAAE;MACzB,OAAOV,cAAc,CACnBQ,gBAAgB,EAChB,CAAC,CAAC,EAAEJ,kBAAkB,CAACO,KAAK,CAAC,EAC7BF,MACF,CAAC;IACH;IAEAH,iBAAiB,CAACK,KAAK,GAAGX,cAAc,CACtCQ,gBAAgB,EAChB,CAACH,kBAAkB,CAACM,KAAK,EAAEP,kBAAkB,CAACO,KAAK,CAAC,EACpDJ,8BAA8B,CAACI,KAAK,GAChC,CAACL,iBAAiB,CAACK,KAAK,EAAEF,MAAM,CAAC,CAAC,CAAC,CAAC,GACpCA,MACN,CAAC;IAED,OAAOH,iBAAiB,CAACK,KAAK;EAChC,CAAC;EAEDT,kBAAkB,CAChB;IACEU,OAAO,EAAGC,CAAC,IAAK;MACd,SAAS;;MAET,MAAMC,oBAAoB,GAAGD,CAAC,CAACE,MAAM,KAAK,CAAC;;MAE3C;MACA,IAAID,oBAAoB,EAAE;QACxBP,8BAA8B,CAACI,KAAK,GAAG,KAAK;QAC5CN,kBAAkB,CAACM,KAAK,GAAG,CAAC;MAC9B;;MAEA;MACA;MACE;MACAP,kBAAkB,CAACO,KAAK,KAAK,CAAC;MAC9B;MACAP,kBAAkB,CAACO,KAAK,KAAKE,CAAC,CAACE,MAAM;MACrC;MACA,CAACD,oBAAoB,EACrB;QACAT,kBAAkB,CAACM,KAAK,GAAGP,kBAAkB,CAACO,KAAK;QACnDJ,8BAA8B,CAACI,KAAK,GAAG,IAAI;MAC7C;;MAEA;MACA,IAAI,CAACG,oBAAoB,EAAE;QACzBV,kBAAkB,CAACO,KAAK,GAAGE,CAAC,CAACE,MAAM;MACrC;IACF,CAAC;IACDC,KAAK,EAAGH,CAAC,IAAK;MACZ,SAAS;;MAET;MACA;MACAT,kBAAkB,CAACO,KAAK,GAAGE,CAAC,CAACE,MAAM;IACrC;EACF,CAAC,EACD,EACF,CAAC;EAED,OAAO;IAAEhB;EAAY,CAAC;AACxB,CAAC;AAED,eAAeI,wBAAwB"}