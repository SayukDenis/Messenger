import React, { useEffect, useMemo, useState } from "react";
import { Animated, Platform, StyleSheet } from "react-native";
import Reanimated, { useSharedValue } from "react-native-reanimated";
import { KeyboardControllerView } from "./bindings";
import { KeyboardContext } from "./context";
import { useAnimatedValue, useSharedHandlers } from "./internal";
import { applyMonkeyPatch, revertMonkeyPatch } from "./monkey-patch";
import { useAnimatedKeyboardHandler, useFocusedInputLayoutHandler, useFocusedInputTextHandler } from "./reanimated";
const KeyboardControllerViewAnimated = Reanimated.createAnimatedComponent(Animated.createAnimatedComponent(KeyboardControllerView));
const styles = StyleSheet.create({
  container: {
    flex: 1
  },
  hidden: {
    display: "none",
    position: "absolute"
  }
});
// capture `Platform.OS` in separate variable to avoid deep workletization of entire RN package
// see https://github.com/kirillzyusko/react-native-keyboard-controller/issues/393 and https://github.com/kirillzyusko/react-native-keyboard-controller/issues/294 for more details
const OS = Platform.OS;
export const KeyboardProvider = ({
  children,
  statusBarTranslucent,
  navigationBarTranslucent,
  enabled: initiallyEnabled = true
}) => {
  // state
  const [enabled, setEnabled] = useState(initiallyEnabled);
  // animated values
  const progress = useAnimatedValue(0);
  const height = useAnimatedValue(0);
  // shared values
  const progressSV = useSharedValue(0);
  const heightSV = useSharedValue(0);
  const layout = useSharedValue(null);
  const [setKeyboardHandlers, broadcastKeyboardEvents] = useSharedHandlers();
  const [setInputHandlers, broadcastInputEvents] = useSharedHandlers();
  // memo
  const context = useMemo(() => ({
    enabled,
    animated: {
      progress: progress,
      height: Animated.multiply(height, -1)
    },
    reanimated: {
      progress: progressSV,
      height: heightSV
    },
    layout,
    setKeyboardHandlers,
    setInputHandlers,
    setEnabled
  }), [enabled]);
  const style = useMemo(() => [styles.hidden, {
    transform: [{
      translateX: height
    }, {
      translateY: progress
    }]
  }], []);
  const onKeyboardMove = useMemo(() => Animated.event([{
    nativeEvent: {
      progress,
      height
    }
  }], {
    useNativeDriver: true
  }), []);
  // handlers
  const updateSharedValues = (event, platforms) => {
    "worklet";

    if (platforms.includes(OS)) {
      progressSV.value = event.progress;
      heightSV.value = -event.height;
    }
  };
  const keyboardHandler = useAnimatedKeyboardHandler({
    onKeyboardMoveStart: event => {
      "worklet";

      broadcastKeyboardEvents("onStart", event);
      updateSharedValues(event, ["ios"]);
    },
    onKeyboardMove: event => {
      "worklet";

      broadcastKeyboardEvents("onMove", event);
      updateSharedValues(event, ["android"]);
    },
    onKeyboardMoveEnd: event => {
      "worklet";

      broadcastKeyboardEvents("onEnd", event);
    },
    onKeyboardMoveInteractive: event => {
      "worklet";

      updateSharedValues(event, ["android", "ios"]);
      broadcastKeyboardEvents("onInteractive", event);
    }
  }, []);
  const inputLayoutHandler = useFocusedInputLayoutHandler({
    onFocusedInputLayoutChanged: e => {
      "worklet";

      if (e.target !== -1) {
        layout.value = e;
      } else {
        layout.value = null;
      }
    }
  }, []);
  const inputTextHandler = useFocusedInputTextHandler({
    onFocusedInputTextChanged: e => {
      "worklet";

      broadcastInputEvents("onChangeText", e);
    }
  }, []);
  // effects
  useEffect(() => {
    if (enabled) {
      applyMonkeyPatch();
    } else {
      revertMonkeyPatch();
    }
  }, [enabled]);
  return /*#__PURE__*/React.createElement(KeyboardContext.Provider, {
    value: context
  }, /*#__PURE__*/React.createElement(KeyboardControllerViewAnimated, {
    enabled: enabled,
    onKeyboardMoveReanimated: keyboardHandler,
    onKeyboardMoveStart: OS === "ios" ? onKeyboardMove : undefined,
    onKeyboardMove: OS === "android" ? onKeyboardMove : undefined,
    onKeyboardMoveInteractive: onKeyboardMove,
    onFocusedInputLayoutChangedReanimated: inputLayoutHandler,
    onFocusedInputTextChangedReanimated: inputTextHandler,
    navigationBarTranslucent: navigationBarTranslucent,
    statusBarTranslucent: statusBarTranslucent,
    style: styles.container
  }, children), /*#__PURE__*/React.createElement(Animated.View, {
    // we are using this small hack, because if the component (where
    // animated value has been used) is unmounted, then animation will
    // stop receiving events (seems like it's react-native optimization).
    // So we need to keep a reference to the animated value, to keep it's
    // always mounted (keep a reference to an animated value).
    //
    // To test why it's needed, try to open screen which consumes Animated.Value
    // then close it and open it again (for example 'Animated transition').
    style: style
  }));
};
//# sourceMappingURL=animated.js.map