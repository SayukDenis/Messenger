{"ast":null,"code":"export {};","map":{"version":3,"names":[],"sources":["D:\\repo\\Messenger\\Messenger\\node_modules\\@react-navigation\\routers\\src\\types.tsx"],"sourcesContent":["import type * as CommonActions from './CommonActions';\r\n\r\nexport type CommonNavigationAction = CommonActions.Action;\r\n\r\ntype NavigationRoute<\r\n  ParamList extends ParamListBase,\r\n  RouteName extends keyof ParamList\r\n> = Route<Extract<RouteName, string>, ParamList[RouteName]> & {\r\n  state?: NavigationState | PartialState<NavigationState>;\r\n};\r\n\r\nexport type NavigationState<ParamList extends ParamListBase = ParamListBase> =\r\n  Readonly<{\r\n    /**\r\n     * Unique key for the navigation state.\r\n     */\r\n    key: string;\r\n    /**\r\n     * Index of the currently focused route.\r\n     */\r\n    index: number;\r\n    /**\r\n     * List of valid route names as defined in the screen components.\r\n     */\r\n    routeNames: Extract<keyof ParamList, string>[];\r\n    /**\r\n     * Alternative entries for history.\r\n     */\r\n    history?: unknown[];\r\n    /**\r\n     * List of rendered routes.\r\n     */\r\n    routes: NavigationRoute<ParamList, keyof ParamList>[];\r\n    /**\r\n     * Custom type for the state, whether it's for tab, stack, drawer etc.\r\n     * During rehydration, the state will be discarded if type doesn't match with router type.\r\n     * It can also be used to detect the type of the navigator we're dealing with.\r\n     */\r\n    type: string;\r\n    /**\r\n     * Whether the navigation state has been rehydrated.\r\n     */\r\n    stale: false;\r\n  }>;\r\n\r\nexport type InitialState = Readonly<\r\n  Partial<Omit<NavigationState, 'stale' | 'routes'>> & {\r\n    routes: (Omit<Route<string>, 'key'> & { state?: InitialState })[];\r\n  }\r\n>;\r\n\r\nexport type PartialRoute<R extends Route<string>> = Omit<R, 'key'> & {\r\n  key?: string;\r\n  state?: PartialState<NavigationState>;\r\n};\r\n\r\nexport type PartialState<State extends NavigationState> = Partial<\r\n  Omit<State, 'stale' | 'routes'>\r\n> &\r\n  Readonly<{\r\n    stale?: true;\r\n    routes: PartialRoute<Route<State['routeNames'][number]>>[];\r\n  }>;\r\n\r\nexport type Route<\r\n  RouteName extends string,\r\n  Params extends object | undefined = object | undefined\r\n> = Readonly<{\r\n  /**\r\n   * Unique key for the route.\r\n   */\r\n  key: string;\r\n  /**\r\n   * User-provided name for the route.\r\n   */\r\n  name: RouteName;\r\n  /**\r\n   * Path associated with the route.\r\n   * Usually present when the screen was opened from a deep link.\r\n   */\r\n  path?: string;\r\n}> &\r\n  (undefined extends Params\r\n    ? Readonly<{\r\n        /**\r\n         * Params for this route\r\n         */\r\n        params?: Readonly<Params>;\r\n      }>\r\n    : Readonly<{\r\n        /**\r\n         * Params for this route\r\n         */\r\n        params: Readonly<Params>;\r\n      }>);\r\n\r\nexport type ParamListBase = Record<string, object | undefined>;\r\n\r\nexport type NavigationAction = Readonly<{\r\n  /**\r\n   * Type of the action (e.g. `NAVIGATE`)\r\n   */\r\n  type: string;\r\n  /**\r\n   * Additional data for the action\r\n   */\r\n  payload?: object;\r\n  /**\r\n   * Key of the route which dispatched this action.\r\n   */\r\n  source?: string;\r\n  /**\r\n   * Key of the navigator which should handle this action.\r\n   */\r\n  target?: string;\r\n}>;\r\n\r\nexport type ActionCreators<Action extends NavigationAction> = {\r\n  [key: string]: (...args: any) => Action;\r\n};\r\n\r\nexport type DefaultRouterOptions<RouteName extends string = string> = {\r\n  /**\r\n   * Name of the route to focus by on initial render.\r\n   * If not specified, usually the first route is used.\r\n   */\r\n  initialRouteName?: RouteName;\r\n};\r\n\r\nexport type RouterFactory<\r\n  State extends NavigationState,\r\n  Action extends NavigationAction,\r\n  RouterOptions extends DefaultRouterOptions\r\n> = (options: RouterOptions) => Router<State, Action>;\r\n\r\nexport type RouterConfigOptions = {\r\n  routeNames: string[];\r\n  routeParamList: ParamListBase;\r\n  routeGetIdList: Record<\r\n    string,\r\n    | ((options: { params?: Record<string, any> }) => string | undefined)\r\n    | undefined\r\n  >;\r\n};\r\n\r\nexport type Router<\r\n  State extends NavigationState,\r\n  Action extends NavigationAction\r\n> = {\r\n  /**\r\n   * Type of the router. Should match the `type` property in state.\r\n   * If the type doesn't match, the state will be discarded during rehydration.\r\n   */\r\n  type: State['type'];\r\n\r\n  /**\r\n   * Initialize the navigation state.\r\n   *\r\n   * @param options.routeNames List of valid route names as defined in the screen components.\r\n   * @param options.routeParamsList Object containing params for each route.\r\n   */\r\n  getInitialState(options: RouterConfigOptions): State;\r\n\r\n  /**\r\n   * Rehydrate the full navigation state from a given partial state.\r\n   *\r\n   * @param partialState Navigation state to rehydrate from.\r\n   * @param options.routeNames List of valid route names as defined in the screen components.\r\n   * @param options.routeParamsList Object containing params for each route.\r\n   */\r\n  getRehydratedState(\r\n    partialState: PartialState<State> | State,\r\n    options: RouterConfigOptions\r\n  ): State;\r\n\r\n  /**\r\n   * Take the current state and updated list of route names, and return a new state.\r\n   *\r\n   * @param state State object to update.\r\n   * @param options.routeNames New list of route names.\r\n   * @param options.routeParamsList Object containing params for each route.\r\n   */\r\n  getStateForRouteNamesChange(\r\n    state: State,\r\n    options: RouterConfigOptions & {\r\n      /**\r\n       * List of routes whose key has changed even if they still have the same name.\r\n       * This allows to remove screens declaratively.\r\n       */\r\n      routeKeyChanges: string[];\r\n    }\r\n  ): State;\r\n\r\n  /**\r\n   * Take the current state and key of a route, and return a new state with the route focused\r\n   *\r\n   * @param state State object to apply the action on.\r\n   * @param key Key of the route to focus.\r\n   */\r\n  getStateForRouteFocus(state: State, key: string): State;\r\n\r\n  /**\r\n   * Take the current state and action, and return a new state.\r\n   * If the action cannot be handled, return `null`.\r\n   *\r\n   * @param state State object to apply the action on.\r\n   * @param action Action object to apply.\r\n   * @param options.routeNames List of valid route names as defined in the screen components.\r\n   * @param options.routeParamsList Object containing params for each route.\r\n   */\r\n  getStateForAction(\r\n    state: State,\r\n    action: Action,\r\n    options: RouterConfigOptions\r\n  ): State | PartialState<State> | null;\r\n\r\n  /**\r\n   * Whether the action should also change focus in parent navigator\r\n   *\r\n   * @param action Action object to check.\r\n   */\r\n  shouldActionChangeFocus(action: NavigationAction): boolean;\r\n\r\n  /**\r\n   * Action creators for the router.\r\n   */\r\n  actionCreators?: ActionCreators<Action>;\r\n};\r\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}