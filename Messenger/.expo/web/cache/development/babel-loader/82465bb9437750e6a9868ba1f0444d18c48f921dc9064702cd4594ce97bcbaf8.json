{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar BatchedBridge = require(\"./BatchedBridge\");\nvar invariant = require('invariant');\nfunction genModule(config, moduleID) {\n  if (!config) {\n    return null;\n  }\n  var _config = _slicedToArray(config, 5),\n    moduleName = _config[0],\n    constants = _config[1],\n    methods = _config[2],\n    promiseMethods = _config[3],\n    syncMethods = _config[4];\n  invariant(!moduleName.startsWith('RCT') && !moduleName.startsWith('RK'), \"Module name prefixes should've been stripped by the native side \" + \"but wasn't for \" + moduleName);\n  if (!constants && !methods) {\n    return {\n      name: moduleName\n    };\n  }\n  var module = {};\n  methods && methods.forEach(function (methodName, methodID) {\n    var isPromise = promiseMethods && arrayContains(promiseMethods, methodID) || false;\n    var isSync = syncMethods && arrayContains(syncMethods, methodID) || false;\n    invariant(!isPromise || !isSync, 'Cannot have a method that is both async and a sync hook');\n    var methodType = isPromise ? 'promise' : isSync ? 'sync' : 'async';\n    module[methodName] = genMethod(moduleID, methodID, methodType);\n  });\n  Object.assign(module, constants);\n  if (module.getConstants == null) {\n    module.getConstants = function () {\n      return constants || Object.freeze({});\n    };\n  } else {\n    console.warn(`Unable to define method 'getConstants()' on NativeModule '${moduleName}'. NativeModule '${moduleName}' already has a constant or method called 'getConstants'. Please remove it.`);\n  }\n  if (__DEV__) {\n    BatchedBridge.createDebugLookup(moduleID, moduleName, methods);\n  }\n  return {\n    name: moduleName,\n    module: module\n  };\n}\nglobal.__fbGenNativeModule = genModule;\nfunction loadModule(name, moduleID) {\n  invariant(global.nativeRequireModuleConfig, \"Can't lazily create module without nativeRequireModuleConfig\");\n  var config = global.nativeRequireModuleConfig(name);\n  var info = genModule(config, moduleID);\n  return info && info.module;\n}\nfunction genMethod(moduleID, methodID, type) {\n  var fn = null;\n  if (type === 'promise') {\n    fn = function promiseMethodWrapper() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      var enqueueingFrameError = new Error();\n      return new Promise(function (resolve, reject) {\n        BatchedBridge.enqueueNativeCall(moduleID, methodID, args, function (data) {\n          return resolve(data);\n        }, function (errorData) {\n          return reject(updateErrorWithErrorData(errorData, enqueueingFrameError));\n        });\n      });\n    };\n  } else {\n    fn = function nonPromiseMethodWrapper() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      var lastArg = args.length > 0 ? args[args.length - 1] : null;\n      var secondLastArg = args.length > 1 ? args[args.length - 2] : null;\n      var hasSuccessCallback = typeof lastArg === 'function';\n      var hasErrorCallback = typeof secondLastArg === 'function';\n      hasErrorCallback && invariant(hasSuccessCallback, 'Cannot have a non-function arg after a function arg.');\n      var onSuccess = hasSuccessCallback ? lastArg : null;\n      var onFail = hasErrorCallback ? secondLastArg : null;\n      var callbackCount = hasSuccessCallback + hasErrorCallback;\n      var newArgs = args.slice(0, args.length - callbackCount);\n      if (type === 'sync') {\n        return BatchedBridge.callNativeSyncHook(moduleID, methodID, newArgs, onFail, onSuccess);\n      } else {\n        BatchedBridge.enqueueNativeCall(moduleID, methodID, newArgs, onFail, onSuccess);\n      }\n    };\n  }\n  fn.type = type;\n  return fn;\n}\nfunction arrayContains(array, value) {\n  return array.indexOf(value) !== -1;\n}\nfunction updateErrorWithErrorData(errorData, error) {\n  return Object.assign(error, errorData || {});\n}\nvar NativeModules = {};\nif (global.nativeModuleProxy) {\n  NativeModules = global.nativeModuleProxy;\n} else if (!global.nativeExtensions) {\n  var bridgeConfig = global.__fbBatchedBridgeConfig;\n  invariant(bridgeConfig, '__fbBatchedBridgeConfig is not set, cannot invoke native modules');\n  var defineLazyObjectProperty = require(\"../Utilities/defineLazyObjectProperty\");\n  (bridgeConfig.remoteModuleConfig || []).forEach(function (config, moduleID) {\n    var info = genModule(config, moduleID);\n    if (!info) {\n      return;\n    }\n    if (info.module) {\n      NativeModules[info.name] = info.module;\n    } else {\n      defineLazyObjectProperty(NativeModules, info.name, {\n        get: function get() {\n          return loadModule(info.name, moduleID);\n        }\n      });\n    }\n  });\n}\nmodule.exports = NativeModules;","map":{"version":3,"names":["_slicedToArray","require","BatchedBridge","invariant","genModule","config","moduleID","_config","moduleName","constants","methods","promiseMethods","syncMethods","startsWith","name","module","forEach","methodName","methodID","isPromise","arrayContains","isSync","methodType","genMethod","Object","assign","getConstants","freeze","console","warn","__DEV__","createDebugLookup","global","__fbGenNativeModule","loadModule","nativeRequireModuleConfig","info","type","fn","promiseMethodWrapper","_len","arguments","length","args","Array","_key","enqueueingFrameError","Error","Promise","resolve","reject","enqueueNativeCall","data","errorData","updateErrorWithErrorData","nonPromiseMethodWrapper","_len2","_key2","lastArg","secondLastArg","hasSuccessCallback","hasErrorCallback","onSuccess","onFail","callbackCount","newArgs","slice","callNativeSyncHook","array","value","indexOf","error","NativeModules","nativeModuleProxy","nativeExtensions","bridgeConfig","__fbBatchedBridgeConfig","defineLazyObjectProperty","remoteModuleConfig","get","exports"],"sources":["D:/project/try1/Messenger/Messenger/node_modules/react-native/Libraries/BatchedBridge/NativeModules.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @format\r\n * @flow strict\r\n */\r\n\r\n'use strict';\r\n\r\nimport type {ExtendedError} from '../Core/ExtendedError';\r\n\r\nconst BatchedBridge = require('./BatchedBridge');\r\nconst invariant = require('invariant');\r\n\r\nexport type ModuleConfig = [\r\n  string /* name */,\r\n  ?{...} /* constants */,\r\n  ?$ReadOnlyArray<string> /* functions */,\r\n  ?$ReadOnlyArray<number> /* promise method IDs */,\r\n  ?$ReadOnlyArray<number> /* sync method IDs */,\r\n];\r\n\r\nexport type MethodType = 'async' | 'promise' | 'sync';\r\n\r\nfunction genModule(\r\n  config: ?ModuleConfig,\r\n  moduleID: number,\r\n): ?{\r\n  name: string,\r\n  module?: {...},\r\n  ...\r\n} {\r\n  if (!config) {\r\n    return null;\r\n  }\r\n\r\n  const [moduleName, constants, methods, promiseMethods, syncMethods] = config;\r\n  invariant(\r\n    !moduleName.startsWith('RCT') && !moduleName.startsWith('RK'),\r\n    \"Module name prefixes should've been stripped by the native side \" +\r\n      \"but wasn't for \" +\r\n      moduleName,\r\n  );\r\n\r\n  if (!constants && !methods) {\r\n    // Module contents will be filled in lazily later\r\n    return {name: moduleName};\r\n  }\r\n\r\n  const module: {[string]: mixed} = {};\r\n  methods &&\r\n    methods.forEach((methodName, methodID) => {\r\n      const isPromise =\r\n        (promiseMethods && arrayContains(promiseMethods, methodID)) || false;\r\n      const isSync =\r\n        (syncMethods && arrayContains(syncMethods, methodID)) || false;\r\n      invariant(\r\n        !isPromise || !isSync,\r\n        'Cannot have a method that is both async and a sync hook',\r\n      );\r\n      const methodType = isPromise ? 'promise' : isSync ? 'sync' : 'async';\r\n      module[methodName] = genMethod(moduleID, methodID, methodType);\r\n    });\r\n\r\n  Object.assign(module, constants);\r\n\r\n  if (module.getConstants == null) {\r\n    module.getConstants = () => constants || Object.freeze({});\r\n  } else {\r\n    console.warn(\r\n      `Unable to define method 'getConstants()' on NativeModule '${moduleName}'. NativeModule '${moduleName}' already has a constant or method called 'getConstants'. Please remove it.`,\r\n    );\r\n  }\r\n\r\n  if (__DEV__) {\r\n    BatchedBridge.createDebugLookup(moduleID, moduleName, methods);\r\n  }\r\n\r\n  return {name: moduleName, module};\r\n}\r\n\r\n// export this method as a global so we can call it from native\r\nglobal.__fbGenNativeModule = genModule;\r\n\r\nfunction loadModule(name: string, moduleID: number): ?{...} {\r\n  invariant(\r\n    global.nativeRequireModuleConfig,\r\n    \"Can't lazily create module without nativeRequireModuleConfig\",\r\n  );\r\n  const config = global.nativeRequireModuleConfig(name);\r\n  const info = genModule(config, moduleID);\r\n  return info && info.module;\r\n}\r\n\r\nfunction genMethod(moduleID: number, methodID: number, type: MethodType) {\r\n  let fn = null;\r\n  if (type === 'promise') {\r\n    fn = function promiseMethodWrapper(...args: Array<mixed>) {\r\n      // In case we reject, capture a useful stack trace here.\r\n      /* $FlowFixMe[class-object-subtyping] added when improving typing for\r\n       * this parameters */\r\n      const enqueueingFrameError: ExtendedError = new Error();\r\n      return new Promise((resolve, reject) => {\r\n        BatchedBridge.enqueueNativeCall(\r\n          moduleID,\r\n          methodID,\r\n          args,\r\n          data => resolve(data),\r\n          errorData =>\r\n            reject(\r\n              updateErrorWithErrorData(\r\n                (errorData: $FlowFixMe),\r\n                enqueueingFrameError,\r\n              ),\r\n            ),\r\n        );\r\n      });\r\n    };\r\n  } else {\r\n    fn = function nonPromiseMethodWrapper(...args: Array<mixed>) {\r\n      const lastArg = args.length > 0 ? args[args.length - 1] : null;\r\n      const secondLastArg = args.length > 1 ? args[args.length - 2] : null;\r\n      const hasSuccessCallback = typeof lastArg === 'function';\r\n      const hasErrorCallback = typeof secondLastArg === 'function';\r\n      hasErrorCallback &&\r\n        invariant(\r\n          hasSuccessCallback,\r\n          'Cannot have a non-function arg after a function arg.',\r\n        );\r\n      // $FlowFixMe[incompatible-type]\r\n      const onSuccess: ?(mixed) => void = hasSuccessCallback ? lastArg : null;\r\n      // $FlowFixMe[incompatible-type]\r\n      const onFail: ?(mixed) => void = hasErrorCallback ? secondLastArg : null;\r\n      // $FlowFixMe[unsafe-addition]\r\n      const callbackCount = hasSuccessCallback + hasErrorCallback;\r\n      const newArgs = args.slice(0, args.length - callbackCount);\r\n      if (type === 'sync') {\r\n        return BatchedBridge.callNativeSyncHook(\r\n          moduleID,\r\n          methodID,\r\n          newArgs,\r\n          onFail,\r\n          onSuccess,\r\n        );\r\n      } else {\r\n        BatchedBridge.enqueueNativeCall(\r\n          moduleID,\r\n          methodID,\r\n          newArgs,\r\n          onFail,\r\n          onSuccess,\r\n        );\r\n      }\r\n    };\r\n  }\r\n  // $FlowFixMe[prop-missing]\r\n  fn.type = type;\r\n  return fn;\r\n}\r\n\r\nfunction arrayContains<T>(array: $ReadOnlyArray<T>, value: T): boolean {\r\n  return array.indexOf(value) !== -1;\r\n}\r\n\r\nfunction updateErrorWithErrorData(\r\n  errorData: {message: string, ...},\r\n  error: ExtendedError,\r\n): ExtendedError {\r\n  /* $FlowFixMe[class-object-subtyping] added when improving typing for this\r\n   * parameters */\r\n  return Object.assign(error, errorData || {});\r\n}\r\n\r\nlet NativeModules: {[moduleName: string]: $FlowFixMe, ...} = {};\r\nif (global.nativeModuleProxy) {\r\n  NativeModules = global.nativeModuleProxy;\r\n} else if (!global.nativeExtensions) {\r\n  const bridgeConfig = global.__fbBatchedBridgeConfig;\r\n  invariant(\r\n    bridgeConfig,\r\n    '__fbBatchedBridgeConfig is not set, cannot invoke native modules',\r\n  );\r\n\r\n  const defineLazyObjectProperty = require('../Utilities/defineLazyObjectProperty');\r\n  (bridgeConfig.remoteModuleConfig || []).forEach(\r\n    (config: ModuleConfig, moduleID: number) => {\r\n      // Initially this config will only contain the module name when running in JSC. The actual\r\n      // configuration of the module will be lazily loaded.\r\n      const info = genModule(config, moduleID);\r\n      if (!info) {\r\n        return;\r\n      }\r\n\r\n      if (info.module) {\r\n        NativeModules[info.name] = info.module;\r\n      }\r\n      // If there's no module config, define a lazy getter\r\n      else {\r\n        defineLazyObjectProperty(NativeModules, info.name, {\r\n          get: () => loadModule(info.name, moduleID),\r\n        });\r\n      }\r\n    },\r\n  );\r\n}\r\n\r\nmodule.exports = NativeModules;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}