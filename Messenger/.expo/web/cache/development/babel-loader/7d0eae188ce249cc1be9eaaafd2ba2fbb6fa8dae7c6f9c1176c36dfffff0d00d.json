{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { useEffect, useRef } from 'react';\nimport { initializeSensor, registerSensor, unregisterSensor } from \"../core\";\nimport { SensorType, IOSReferenceFrame } from \"../commonTypes\";\nimport { callMicrotasks } from \"../threads\";\nfunction eulerToQuaternion(pitch, roll, yaw) {\n  'worklet';\n\n  var c1 = Math.cos(pitch / 2);\n  var s1 = Math.sin(pitch / 2);\n  var c2 = Math.cos(roll / 2);\n  var s2 = Math.sin(roll / 2);\n  var c3 = Math.cos(yaw / 2);\n  var s3 = Math.sin(yaw / 2);\n  return [s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3];\n}\nfunction adjustRotationToInterfaceOrientation(data) {\n  'worklet';\n\n  var interfaceOrientation = data.interfaceOrientation,\n    pitch = data.pitch,\n    roll = data.roll,\n    yaw = data.yaw;\n  if (interfaceOrientation === 90) {\n    data.pitch = roll;\n    data.roll = -pitch;\n    data.yaw = yaw - Math.PI / 2;\n  } else if (interfaceOrientation === 270) {\n    data.pitch = -roll;\n    data.roll = pitch;\n    data.yaw = yaw + Math.PI / 2;\n  } else if (interfaceOrientation === 180) {\n    data.pitch *= -1;\n    data.roll *= -1;\n    data.yaw *= -1;\n  }\n  var q = eulerToQuaternion(data.pitch, data.roll, data.yaw);\n  data.qx = q[0];\n  data.qy = q[1];\n  data.qz = q[2];\n  data.qw = q[3];\n  return data;\n}\nfunction adjustVectorToInterfaceOrientation(data) {\n  'worklet';\n\n  var interfaceOrientation = data.interfaceOrientation,\n    x = data.x,\n    y = data.y;\n  if (interfaceOrientation === 90) {\n    data.x = -y;\n    data.y = x;\n  } else if (interfaceOrientation === 270) {\n    data.x = y;\n    data.y = -x;\n  } else if (interfaceOrientation === 180) {\n    data.x *= -1;\n    data.y *= -1;\n  }\n  return data;\n}\nexport function useAnimatedSensor(sensorType, userConfig) {\n  var config = _objectSpread({\n    interval: 'auto',\n    adjustToInterfaceOrientation: true,\n    iosReferenceFrame: IOSReferenceFrame.Auto\n  }, userConfig);\n  var ref = useRef({\n    sensor: initializeSensor(sensorType, config),\n    unregister: function unregister() {},\n    isAvailable: false,\n    config: config\n  });\n  useEffect(function () {\n    var newConfig = _objectSpread(_objectSpread({}, config), userConfig);\n    ref.current.sensor = initializeSensor(sensorType, newConfig);\n    var sensorData = ref.current.sensor;\n    var adjustToInterfaceOrientation = ref.current.config.adjustToInterfaceOrientation;\n    var id = registerSensor(sensorType, config, function (data) {\n      'worklet';\n\n      if (adjustToInterfaceOrientation) {\n        if (sensorType === SensorType.ROTATION) {\n          data = adjustRotationToInterfaceOrientation(data);\n        } else {\n          data = adjustVectorToInterfaceOrientation(data);\n        }\n      }\n      sensorData.value = data;\n      callMicrotasks();\n    });\n    if (id !== -1) {\n      ref.current.unregister = function () {\n        return unregisterSensor(id);\n      };\n      ref.current.isAvailable = true;\n    } else {\n      ref.current.unregister = function () {};\n      ref.current.isAvailable = false;\n    }\n    return function () {\n      ref.current.unregister();\n    };\n  }, [sensorType, userConfig]);\n  return ref.current;\n}","map":{"version":3,"names":["useEffect","useRef","initializeSensor","registerSensor","unregisterSensor","SensorType","IOSReferenceFrame","callMicrotasks","eulerToQuaternion","pitch","roll","yaw","c1","Math","cos","s1","sin","c2","s2","c3","s3","adjustRotationToInterfaceOrientation","data","interfaceOrientation","PI","q","qx","qy","qz","qw","adjustVectorToInterfaceOrientation","x","y","useAnimatedSensor","sensorType","userConfig","config","_objectSpread","interval","adjustToInterfaceOrientation","iosReferenceFrame","Auto","ref","sensor","unregister","isAvailable","newConfig","current","sensorData","id","ROTATION","value"],"sources":["C:\\Users\\Admin\\Project\\Project\\Messenger\\Messenger\\node_modules\\react-native-reanimated\\lib\\module\\reanimated2\\hook\\useAnimatedSensor.ts"],"sourcesContent":["import { useEffect, useRef } from 'react';\nimport { initializeSensor, registerSensor, unregisterSensor } from '../core';\nimport type {\n  SensorConfig,\n  AnimatedSensor,\n  Value3D,\n  ValueRotation,\n} from '../commonTypes';\nimport { SensorType, IOSReferenceFrame } from '../commonTypes';\nimport { callMicrotasks } from '../threads';\n\n// euler angles are in order ZXY, z = yaw, x = pitch, y = roll\n// https://github.com/mrdoob/three.js/blob/dev/src/math/Quaternion.js#L237\nfunction eulerToQuaternion(pitch: number, roll: number, yaw: number) {\n  'worklet';\n  const c1 = Math.cos(pitch / 2);\n  const s1 = Math.sin(pitch / 2);\n  const c2 = Math.cos(roll / 2);\n  const s2 = Math.sin(roll / 2);\n  const c3 = Math.cos(yaw / 2);\n  const s3 = Math.sin(yaw / 2);\n\n  return [\n    s1 * c2 * c3 - c1 * s2 * s3,\n    c1 * s2 * c3 + s1 * c2 * s3,\n    c1 * c2 * s3 + s1 * s2 * c3,\n    c1 * c2 * c3 - s1 * s2 * s3,\n  ];\n}\n\nfunction adjustRotationToInterfaceOrientation(data: ValueRotation) {\n  'worklet';\n  const { interfaceOrientation, pitch, roll, yaw } = data;\n  if (interfaceOrientation === 90) {\n    data.pitch = roll;\n    data.roll = -pitch;\n    data.yaw = yaw - Math.PI / 2;\n  } else if (interfaceOrientation === 270) {\n    data.pitch = -roll;\n    data.roll = pitch;\n    data.yaw = yaw + Math.PI / 2;\n  } else if (interfaceOrientation === 180) {\n    data.pitch *= -1;\n    data.roll *= -1;\n    data.yaw *= -1;\n  }\n\n  const q = eulerToQuaternion(data.pitch, data.roll, data.yaw);\n  data.qx = q[0];\n  data.qy = q[1];\n  data.qz = q[2];\n  data.qw = q[3];\n  return data;\n}\n\nfunction adjustVectorToInterfaceOrientation(data: Value3D) {\n  'worklet';\n  const { interfaceOrientation, x, y } = data;\n  if (interfaceOrientation === 90) {\n    data.x = -y;\n    data.y = x;\n  } else if (interfaceOrientation === 270) {\n    data.x = y;\n    data.y = -x;\n  } else if (interfaceOrientation === 180) {\n    data.x *= -1;\n    data.y *= -1;\n  }\n  return data;\n}\n\nexport function useAnimatedSensor(\n  sensorType: SensorType.ROTATION,\n  userConfig?: Partial<SensorConfig>\n): AnimatedSensor<ValueRotation>;\nexport function useAnimatedSensor(\n  sensorType: Exclude<SensorType, SensorType.ROTATION>,\n  userConfig?: Partial<SensorConfig>\n): AnimatedSensor<Value3D>;\nexport function useAnimatedSensor(\n  sensorType: SensorType,\n  userConfig?: Partial<SensorConfig>\n): AnimatedSensor<any> {\n  const config: SensorConfig = {\n    interval: 'auto',\n    adjustToInterfaceOrientation: true,\n    iosReferenceFrame: IOSReferenceFrame.Auto,\n    ...userConfig,\n  };\n  const ref = useRef<AnimatedSensor<Value3D | ValueRotation>>({\n    sensor: initializeSensor(sensorType, config),\n    unregister: () => {\n      // NOOP\n    },\n    isAvailable: false,\n    config: config,\n  });\n\n  useEffect(() => {\n    const newConfig = {\n      ...config,\n      ...userConfig,\n    };\n    ref.current.sensor = initializeSensor(sensorType, newConfig);\n\n    const sensorData = ref.current.sensor;\n    const adjustToInterfaceOrientation =\n      ref.current.config.adjustToInterfaceOrientation;\n\n    const id = registerSensor(sensorType, config, (data) => {\n      'worklet';\n      if (adjustToInterfaceOrientation) {\n        if (sensorType === SensorType.ROTATION) {\n          data = adjustRotationToInterfaceOrientation(data as ValueRotation);\n        } else {\n          data = adjustVectorToInterfaceOrientation(data as Value3D);\n        }\n      }\n      sensorData.value = data;\n      callMicrotasks();\n    });\n\n    if (id !== -1) {\n      // if sensor is available\n      ref.current.unregister = () => unregisterSensor(id);\n      ref.current.isAvailable = true;\n    } else {\n      // if sensor is unavailable\n      ref.current.unregister = () => {\n        // NOOP\n      };\n      ref.current.isAvailable = false;\n    }\n\n    return () => {\n      ref.current.unregister();\n    };\n  }, [sensorType, userConfig]);\n\n  return ref.current;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}