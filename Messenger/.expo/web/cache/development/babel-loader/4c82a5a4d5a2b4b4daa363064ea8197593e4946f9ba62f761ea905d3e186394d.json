{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar ReactNativeStyleAttributes = require(\"../Components/View/ReactNativeStyleAttributes\");\nvar PixelRatio = require(\"../Utilities/PixelRatio\").default;\nvar flatten = require(\"./flattenStyle\");\nvar hairlineWidth = PixelRatio.roundToNearestPixel(0.4);\nif (hairlineWidth === 0) {\n  hairlineWidth = 1 / PixelRatio.get();\n}\nvar absoluteFill = {\n  position: 'absolute',\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0\n};\nif (__DEV__) {\n  Object.freeze(absoluteFill);\n}\nmodule.exports = {\n  hairlineWidth: hairlineWidth,\n  absoluteFill: absoluteFill,\n  absoluteFillObject: absoluteFill,\n  compose: function compose(style1, style2) {\n    if (style1 != null && style2 != null) {\n      return [style1, style2];\n    } else {\n      return style1 != null ? style1 : style2;\n    }\n  },\n  flatten: flatten,\n  setStyleAttributePreprocessor: function setStyleAttributePreprocessor(property, process) {\n    var _ReactNativeStyleAttr, _ReactNativeStyleAttr2;\n    var value;\n    if (ReactNativeStyleAttributes[property] === true) {\n      value = {\n        process: process\n      };\n    } else if (typeof ReactNativeStyleAttributes[property] === 'object') {\n      value = _objectSpread(_objectSpread({}, ReactNativeStyleAttributes[property]), {}, {\n        process: process\n      });\n    } else {\n      console.error(`${property} is not a valid style attribute`);\n      return;\n    }\n    if (__DEV__ && typeof value.process === 'function' && typeof ((_ReactNativeStyleAttr = ReactNativeStyleAttributes[property]) == null ? void 0 : _ReactNativeStyleAttr.process) === 'function' && value.process !== ((_ReactNativeStyleAttr2 = ReactNativeStyleAttributes[property]) == null ? void 0 : _ReactNativeStyleAttr2.process)) {\n      console.warn(`Overwriting ${property} style attribute preprocessor`);\n    }\n    ReactNativeStyleAttributes[property] = value;\n  },\n  create: function create(obj) {\n    if (__DEV__) {\n      for (var _key in obj) {\n        if (obj[_key]) {\n          Object.freeze(obj[_key]);\n        }\n      }\n    }\n    return obj;\n  }\n};","map":{"version":3,"names":["_defineProperty","require","ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","defineProperty","ReactNativeStyleAttributes","PixelRatio","default","flatten","hairlineWidth","roundToNearestPixel","get","absoluteFill","position","left","right","top","bottom","__DEV__","freeze","module","exports","absoluteFillObject","compose","style1","style2","setStyleAttributePreprocessor","property","process","_ReactNativeStyleAttr","_ReactNativeStyleAttr2","value","console","error","warn","create","obj","key"],"sources":["D:/project/try1/Messenger/Messenger/node_modules/react-native/Libraries/StyleSheet/StyleSheet.js"],"sourcesContent":["/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n * @format\r\n */\r\n\r\n'use strict';\r\n\r\nimport type {\r\n  ____ColorValue_Internal,\r\n  ____DangerouslyImpreciseStyle_Internal,\r\n  ____DangerouslyImpreciseStyleProp_Internal,\r\n  ____ImageStyle_Internal,\r\n  ____ImageStyleProp_Internal,\r\n  ____Styles_Internal,\r\n  ____TextStyle_Internal,\r\n  ____TextStyleProp_Internal,\r\n  ____ViewStyle_Internal,\r\n  ____ViewStyleProp_Internal,\r\n} from './StyleSheetTypes';\r\n\r\nconst ReactNativeStyleAttributes = require('../Components/View/ReactNativeStyleAttributes');\r\nconst PixelRatio = require('../Utilities/PixelRatio').default;\r\nconst flatten = require('./flattenStyle');\r\n\r\n/**\r\n * This type should be used as the type for anything that is a color. It is\r\n * most useful when using DynamicColorIOS which can be a string or a dynamic\r\n * color object.\r\n *\r\n * type props = {backgroundColor: ColorValue};\r\n */\r\nexport type ColorValue = ____ColorValue_Internal;\r\n\r\n/**\r\n * This type should be used as the type for a prop that is passed through\r\n * to a <View>'s `style` prop. This ensures call sites of the component\r\n * can't pass styles that View doesn't support such as `fontSize`.`\r\n *\r\n * type Props = {style: ViewStyleProp}\r\n * const MyComponent = (props: Props) => <View style={props.style} />\r\n */\r\nexport type ViewStyleProp = ____ViewStyleProp_Internal;\r\n\r\n/**\r\n * This type should be used as the type for a prop that is passed through\r\n * to a <Text>'s `style` prop. This ensures call sites of the component\r\n * can't pass styles that Text doesn't support such as `resizeMode`.`\r\n *\r\n * type Props = {style: TextStyleProp}\r\n * const MyComponent = (props: Props) => <Text style={props.style} />\r\n */\r\nexport type TextStyleProp = ____TextStyleProp_Internal;\r\n\r\n/**\r\n * This type should be used as the type for a prop that is passed through\r\n * to an <Image>'s `style` prop. This ensures call sites of the component\r\n * can't pass styles that Image doesn't support such as `fontSize`.`\r\n *\r\n * type Props = {style: ImageStyleProp}\r\n * const MyComponent = (props: Props) => <Image style={props.style} />\r\n */\r\nexport type ImageStyleProp = ____ImageStyleProp_Internal;\r\n\r\n/**\r\n * WARNING: You probably shouldn't be using this type. This type\r\n * is similar to the ones above except it allows styles that are accepted\r\n * by all of View, Text, or Image. It is therefore very unsafe to pass this\r\n * through to an underlying component. Using this is almost always a mistake\r\n * and using one of the other more restrictive types is likely the right choice.\r\n */\r\nexport type DangerouslyImpreciseStyleProp =\r\n  ____DangerouslyImpreciseStyleProp_Internal;\r\n\r\n/**\r\n * Utility type for getting the values for specific style keys.\r\n *\r\n * The following is bad because position is more restrictive than 'string':\r\n * ```\r\n * type Props = {position: string};\r\n * ```\r\n *\r\n * You should use the following instead:\r\n *\r\n * ```\r\n * type Props = {position: TypeForStyleKey<'position'>};\r\n * ```\r\n *\r\n * This will correctly give you the type 'absolute' | 'relative'\r\n */\r\nexport type TypeForStyleKey<\r\n  +key: $Keys<____DangerouslyImpreciseStyle_Internal>,\r\n> = $ElementType<____DangerouslyImpreciseStyle_Internal, key>;\r\n\r\n/**\r\n * This type is an object of the different possible style\r\n * properties that can be specified for View.\r\n *\r\n * Note that this isn't a safe way to type a style prop for a component as\r\n * results from StyleSheet.create return an internal identifier, not\r\n * an object of styles.\r\n *\r\n * If you want to type the style prop of a function,\r\n * consider using ViewStyleProp.\r\n *\r\n * A reasonable usage of this type is for helper functions that return an\r\n * object of styles to pass to a View that can't be precomputed with\r\n * StyleSheet.create.\r\n */\r\nexport type ViewStyle = ____ViewStyle_Internal;\r\n\r\n/**\r\n * This type is an object of the different possible style\r\n * properties that can be specified for Text.\r\n *\r\n * Note that this isn't a safe way to type a style prop for a component as\r\n * results from StyleSheet.create return an internal identifier, not\r\n * an object of styles.\r\n *\r\n * If you want to type the style prop of a function,\r\n * consider using TextStyleProp.\r\n *\r\n * A reasonable usage of this type is for helper functions that return an\r\n * object of styles to pass to a Text that can't be precomputed with\r\n * StyleSheet.create.\r\n */\r\nexport type TextStyle = ____TextStyle_Internal;\r\n\r\n/**\r\n * This type is an object of the different possible style\r\n * properties that can be specified for Image.\r\n *\r\n * Note that this isn't a safe way to type a style prop for a component as\r\n * results from StyleSheet.create return an internal identifier, not\r\n * an object of styles.\r\n *\r\n * If you want to type the style prop of a function,\r\n * consider using ImageStyleProp.\r\n *\r\n * A reasonable usage of this type is for helper functions that return an\r\n * object of styles to pass to an Image that can't be precomputed with\r\n * StyleSheet.create.\r\n */\r\nexport type ImageStyle = ____ImageStyle_Internal;\r\n\r\n/**\r\n * WARNING: You probably shouldn't be using this type. This type is an object\r\n * with all possible style keys and their values. Note that this isn't\r\n * a safe way to type a style prop for a component as results from\r\n * StyleSheet.create return an internal identifier, not an object of styles.\r\n *\r\n * If you want to type the style prop of a function, consider using\r\n * ViewStyleProp, TextStyleProp, or ImageStyleProp.\r\n *\r\n * This should only be used by very core utilities that operate on an object\r\n * containing any possible style value.\r\n */\r\nexport type DangerouslyImpreciseStyle = ____DangerouslyImpreciseStyle_Internal;\r\n\r\nlet hairlineWidth: number = PixelRatio.roundToNearestPixel(0.4);\r\nif (hairlineWidth === 0) {\r\n  hairlineWidth = 1 / PixelRatio.get();\r\n}\r\n\r\nconst absoluteFill = {\r\n  position: 'absolute',\r\n  left: 0,\r\n  right: 0,\r\n  top: 0,\r\n  bottom: 0,\r\n};\r\nif (__DEV__) {\r\n  Object.freeze(absoluteFill);\r\n}\r\n\r\n/**\r\n * A StyleSheet is an abstraction similar to CSS StyleSheets\r\n *\r\n * Create a new StyleSheet:\r\n *\r\n * ```\r\n * const styles = StyleSheet.create({\r\n *   container: {\r\n *     borderRadius: 4,\r\n *     borderWidth: 0.5,\r\n *     borderColor: '#d6d7da',\r\n *   },\r\n *   title: {\r\n *     fontSize: 19,\r\n *     fontWeight: 'bold',\r\n *   },\r\n *   activeTitle: {\r\n *     color: 'red',\r\n *   },\r\n * });\r\n * ```\r\n *\r\n * Use a StyleSheet:\r\n *\r\n * ```\r\n * <View style={styles.container}>\r\n *   <Text style={[styles.title, this.props.isActive && styles.activeTitle]} />\r\n * </View>\r\n * ```\r\n *\r\n * Code quality:\r\n *\r\n *  - By moving styles away from the render function, you're making the code\r\n *  easier to understand.\r\n *  - Naming the styles is a good way to add meaning to the low level components\r\n *  in the render function.\r\n *\r\n * Performance:\r\n *\r\n *  - Making a stylesheet from a style object makes it possible to refer to it\r\n * by ID instead of creating a new style object every time.\r\n *  - It also allows to send the style only once through the bridge. All\r\n * subsequent uses are going to refer an id (not implemented yet).\r\n */\r\nmodule.exports = {\r\n  /**\r\n   * This is defined as the width of a thin line on the platform. It can be\r\n   * used as the thickness of a border or division between two elements.\r\n   * Example:\r\n   * ```\r\n   *   {\r\n   *     borderBottomColor: '#bbb',\r\n   *     borderBottomWidth: StyleSheet.hairlineWidth\r\n   *   }\r\n   * ```\r\n   *\r\n   * This constant will always be a round number of pixels (so a line defined\r\n   * by it look crisp) and will try to match the standard width of a thin line\r\n   * on the underlying platform. However, you should not rely on it being a\r\n   * constant size, because on different platforms and screen densities its\r\n   * value may be calculated differently.\r\n   *\r\n   * A line with hairline width may not be visible if your simulator is downscaled.\r\n   */\r\n  hairlineWidth,\r\n\r\n  /**\r\n   * A very common pattern is to create overlays with position absolute and zero positioning,\r\n   * so `absoluteFill` can be used for convenience and to reduce duplication of these repeated\r\n   * styles.\r\n   */\r\n  absoluteFill: (absoluteFill: any), // TODO: This should be updated after we fix downstream Flow sites.\r\n\r\n  /**\r\n   * Sometimes you may want `absoluteFill` but with a couple tweaks - `absoluteFillObject` can be\r\n   * used to create a customized entry in a `StyleSheet`, e.g.:\r\n   *\r\n   *   const styles = StyleSheet.create({\r\n   *     wrapper: {\r\n   *       ...StyleSheet.absoluteFillObject,\r\n   *       top: 10,\r\n   *       backgroundColor: 'transparent',\r\n   *     },\r\n   *   });\r\n   */\r\n  absoluteFillObject: absoluteFill,\r\n\r\n  /**\r\n   * Combines two styles such that `style2` will override any styles in `style1`.\r\n   * If either style is falsy, the other one is returned without allocating an\r\n   * array, saving allocations and maintaining reference equality for\r\n   * PureComponent checks.\r\n   */\r\n  compose<T: DangerouslyImpreciseStyleProp>(\r\n    style1: ?T,\r\n    style2: ?T,\r\n  ): ?T | $ReadOnlyArray<T> {\r\n    if (style1 != null && style2 != null) {\r\n      return ([style1, style2]: $ReadOnlyArray<T>);\r\n    } else {\r\n      return style1 != null ? style1 : style2;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Flattens an array of style objects, into one aggregated style object.\r\n   * Alternatively, this method can be used to lookup IDs, returned by\r\n   * StyleSheet.register.\r\n   *\r\n   * > **NOTE**: Exercise caution as abusing this can tax you in terms of\r\n   * > optimizations.\r\n   * >\r\n   * > IDs enable optimizations through the bridge and memory in general. Referring\r\n   * > to style objects directly will deprive you of these optimizations.\r\n   *\r\n   * Example:\r\n   * ```\r\n   * const styles = StyleSheet.create({\r\n   *   listItem: {\r\n   *     flex: 1,\r\n   *     fontSize: 16,\r\n   *     color: 'white'\r\n   *   },\r\n   *   selectedListItem: {\r\n   *     color: 'green'\r\n   *   }\r\n   * });\r\n   *\r\n   * StyleSheet.flatten([styles.listItem, styles.selectedListItem])\r\n   * // returns { flex: 1, fontSize: 16, color: 'green' }\r\n   * ```\r\n   * Alternative use:\r\n   * ```\r\n   * StyleSheet.flatten(styles.listItem);\r\n   * // return { flex: 1, fontSize: 16, color: 'white' }\r\n   * // Simply styles.listItem would return its ID (number)\r\n   * ```\r\n   * This method internally uses `StyleSheetRegistry.getStyleByID(style)`\r\n   * to resolve style objects represented by IDs. Thus, an array of style\r\n   * objects (instances of StyleSheet.create), are individually resolved to,\r\n   * their respective objects, merged as one and then returned. This also explains\r\n   * the alternative use.\r\n   */\r\n  flatten,\r\n\r\n  /**\r\n   * WARNING: EXPERIMENTAL. Breaking changes will probably happen a lot and will\r\n   * not be reliably announced. The whole thing might be deleted, who knows? Use\r\n   * at your own risk.\r\n   *\r\n   * Sets a function to use to pre-process a style property value. This is used\r\n   * internally to process color and transform values. You should not use this\r\n   * unless you really know what you are doing and have exhausted other options.\r\n   */\r\n  setStyleAttributePreprocessor(\r\n    property: string,\r\n    process: (nextProp: mixed) => mixed,\r\n  ) {\r\n    let value;\r\n\r\n    if (ReactNativeStyleAttributes[property] === true) {\r\n      value = {process};\r\n    } else if (typeof ReactNativeStyleAttributes[property] === 'object') {\r\n      value = {...ReactNativeStyleAttributes[property], process};\r\n    } else {\r\n      console.error(`${property} is not a valid style attribute`);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      __DEV__ &&\r\n      typeof value.process === 'function' &&\r\n      typeof ReactNativeStyleAttributes[property]?.process === 'function' &&\r\n      value.process !== ReactNativeStyleAttributes[property]?.process\r\n    ) {\r\n      console.warn(`Overwriting ${property} style attribute preprocessor`);\r\n    }\r\n\r\n    ReactNativeStyleAttributes[property] = value;\r\n  },\r\n\r\n  /**\r\n   * Creates a StyleSheet style reference from the given object.\r\n   */\r\n  create<+S: ____Styles_Internal>(obj: S): $ReadOnly<S> {\r\n    // TODO: This should return S as the return type. But first,\r\n    // we need to codemod all the callsites that are typing this\r\n    // return value as a number (even though it was opaque).\r\n    if (__DEV__) {\r\n      for (const key in obj) {\r\n        if (obj[key]) {\r\n          Object.freeze(obj[key]);\r\n        }\r\n      }\r\n    }\r\n    return obj;\r\n  },\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}