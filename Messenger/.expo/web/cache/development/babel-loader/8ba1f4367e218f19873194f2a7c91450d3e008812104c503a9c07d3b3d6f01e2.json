{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nexport var PrivateValueStore = _createClass(function PrivateValueStore() {\n  _classCallCheck(this, PrivateValueStore);\n});","map":{"version":3,"names":["PrivateValueStore","_createClass","_classCallCheck"],"sources":["D:\\project\\ty\\Messenger\\Messenger\\node_modules\\@react-navigation\\core\\src\\types.tsx"],"sourcesContent":["import type {\r\n  DefaultRouterOptions,\r\n  InitialState,\r\n  NavigationAction,\r\n  NavigationState,\r\n  ParamListBase,\r\n  PartialState,\r\n  Route,\r\n} from '@react-navigation/routers';\r\nimport type * as React from 'react';\r\n\r\ndeclare global {\r\n  // eslint-disable-next-line @typescript-eslint/no-namespace\r\n  namespace ReactNavigation {\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-interface\r\n    interface RootParamList {}\r\n  }\r\n}\r\n\r\ntype Keyof<T extends {}> = Extract<keyof T, string>;\r\n\r\nexport type DefaultNavigatorOptions<\r\n  ParamList extends ParamListBase,\r\n  State extends NavigationState,\r\n  ScreenOptions extends {},\r\n  EventMap extends EventMapBase\r\n> = DefaultRouterOptions<Keyof<ParamList>> & {\r\n  /**\r\n   * Optional ID for the navigator. Can be used with `navigation.getParent(id)` to refer to a parent.\r\n   */\r\n  id?: string;\r\n  /**\r\n   * Children React Elements to extract the route configuration from.\r\n   * Only `Screen`, `Group` and `React.Fragment` are supported as children.\r\n   */\r\n  children: React.ReactNode;\r\n  /**\r\n   * Event listeners for all the screens in the navigator.\r\n   */\r\n  screenListeners?:\r\n    | ScreenListeners<State, EventMap>\r\n    | ((props: {\r\n        route: RouteProp<ParamList>;\r\n        navigation: any;\r\n      }) => ScreenListeners<State, EventMap>);\r\n  /**\r\n   * Default options for all screens under this navigator.\r\n   */\r\n  screenOptions?:\r\n    | ScreenOptions\r\n    | ((props: {\r\n        route: RouteProp<ParamList>;\r\n        navigation: any;\r\n      }) => ScreenOptions);\r\n};\r\n\r\nexport type EventMapBase = Record<\r\n  string,\r\n  { data?: any; canPreventDefault?: boolean }\r\n>;\r\n\r\nexport type EventMapCore<State extends NavigationState> = {\r\n  focus: { data: undefined };\r\n  blur: { data: undefined };\r\n  state: { data: { state: State } };\r\n  beforeRemove: { data: { action: NavigationAction }; canPreventDefault: true };\r\n};\r\n\r\nexport type EventArg<\r\n  EventName extends string,\r\n  CanPreventDefault extends boolean | undefined = false,\r\n  Data = undefined\r\n> = {\r\n  /**\r\n   * Type of the event (e.g. `focus`, `blur`)\r\n   */\r\n  readonly type: EventName;\r\n  readonly target?: string;\r\n} & (CanPreventDefault extends true\r\n  ? {\r\n      /**\r\n       * Whether `event.preventDefault()` was called on this event object.\r\n       */\r\n      readonly defaultPrevented: boolean;\r\n      /**\r\n       * Prevent the default action which happens on this event.\r\n       */\r\n      preventDefault(): void;\r\n    }\r\n  : {}) &\r\n  (undefined extends Data\r\n    ? { readonly data?: Readonly<Data> }\r\n    : { readonly data: Readonly<Data> });\r\n\r\nexport type EventListenerCallback<\r\n  EventMap extends EventMapBase,\r\n  EventName extends keyof EventMap\r\n> = (\r\n  e: EventArg<\r\n    Extract<EventName, string>,\r\n    EventMap[EventName]['canPreventDefault'],\r\n    EventMap[EventName]['data']\r\n  >\r\n) => void;\r\n\r\nexport type EventConsumer<EventMap extends EventMapBase> = {\r\n  /**\r\n   * Subscribe to events from the parent navigator.\r\n   *\r\n   * @param type Type of the event (e.g. `focus`, `blur`)\r\n   * @param callback Callback listener which is executed upon receiving the event.\r\n   */\r\n  addListener<EventName extends Keyof<EventMap>>(\r\n    type: EventName,\r\n    callback: EventListenerCallback<EventMap, EventName>\r\n  ): () => void;\r\n  removeListener<EventName extends Keyof<EventMap>>(\r\n    type: EventName,\r\n    callback: EventListenerCallback<EventMap, EventName>\r\n  ): void;\r\n};\r\n\r\nexport type EventEmitter<EventMap extends EventMapBase> = {\r\n  /**\r\n   * Emit an event to child screens.\r\n   *\r\n   * @param options.type Type of the event (e.g. `focus`, `blur`)\r\n   * @param [options.data] Optional information regarding the event.\r\n   * @param [options.target] Key of the target route which should receive the event.\r\n   * If not specified, all routes receive the event.\r\n   */\r\n  emit<EventName extends Keyof<EventMap>>(\r\n    options: {\r\n      type: EventName;\r\n      target?: string;\r\n    } & (EventMap[EventName]['canPreventDefault'] extends true\r\n      ? { canPreventDefault: true }\r\n      : {}) &\r\n      (undefined extends EventMap[EventName]['data']\r\n        ? { data?: EventMap[EventName]['data'] }\r\n        : { data: EventMap[EventName]['data'] })\r\n  ): EventArg<\r\n    EventName,\r\n    EventMap[EventName]['canPreventDefault'],\r\n    EventMap[EventName]['data']\r\n  >;\r\n};\r\n\r\nexport class PrivateValueStore<T extends [any, any, any]> {\r\n  /**\r\n   * UGLY HACK! DO NOT USE THE TYPE!!!\r\n   *\r\n   * TypeScript requires a type to be used to be able to infer it.\r\n   * The type should exist as its own without any operations such as union.\r\n   * So we need to figure out a way to store this type in a property.\r\n   * The problem with a normal property is that it shows up in intelliSense.\r\n   * Adding private keyword works, but the annotation is stripped away in declaration.\r\n   * Turns out if we use an empty string, it doesn't show up in intelliSense.\r\n   */\r\n  protected ''?: T;\r\n}\r\n\r\ntype NavigationHelpersCommon<\r\n  ParamList extends ParamListBase,\r\n  State extends NavigationState = NavigationState\r\n> = {\r\n  /**\r\n   * Dispatch an action or an update function to the router.\r\n   * The update function will receive the current state,\r\n   *\r\n   * @param action Action object or update function.\r\n   */\r\n  dispatch(\r\n    action: NavigationAction | ((state: State) => NavigationAction)\r\n  ): void;\r\n\r\n  /**\r\n   * Navigate to a route in current navigation tree.\r\n   *\r\n   * @param name Name of the route to navigate to.\r\n   * @param [params] Params object for the route.\r\n   */\r\n  navigate<RouteName extends keyof ParamList>(\r\n    ...args: // this first condition allows us to iterate over a union type\r\n    // This is to avoid getting a union of all the params from `ParamList[RouteName]`,\r\n    // which will get our types all mixed up if a union RouteName is passed in.\r\n    RouteName extends unknown\r\n      ? // This condition checks if the params are optional,\r\n        // which means it's either undefined or a union with undefined\r\n        undefined extends ParamList[RouteName]\r\n        ?\r\n            | [screen: RouteName] // if the params are optional, we don't have to provide it\r\n            | [screen: RouteName, params: ParamList[RouteName]]\r\n        : [screen: RouteName, params: ParamList[RouteName]]\r\n      : never\r\n  ): void;\r\n\r\n  /**\r\n   * Navigate to a route in current navigation tree.\r\n   *\r\n   * @param route Object with `key` or `name` for the route to navigate to, and a `params` object.\r\n   */\r\n  navigate<RouteName extends keyof ParamList>(\r\n    options: RouteName extends unknown\r\n      ?\r\n          | { key: string; params?: ParamList[RouteName]; merge?: boolean }\r\n          | {\r\n              name: RouteName;\r\n              key?: string;\r\n              params: ParamList[RouteName];\r\n              merge?: boolean;\r\n            }\r\n      : never\r\n  ): void;\r\n\r\n  /**\r\n   * Reset the navigation state to the provided state.\r\n   *\r\n   * @param state Navigation state object.\r\n   */\r\n  reset(state: PartialState<State> | State): void;\r\n\r\n  /**\r\n   * Go back to the previous route in history.\r\n   */\r\n  goBack(): void;\r\n\r\n  /**\r\n   * Check if the screen is focused. The method returns `true` if focused, `false` otherwise.\r\n   * Note that this method doesn't re-render screen when the focus changes. So don't use it in `render`.\r\n   * To get notified of focus changes, use `addListener('focus', cb)` and `addListener('blur', cb)`.\r\n   * To conditionally render content based on focus state, use the `useIsFocused` hook.\r\n   */\r\n  isFocused(): boolean;\r\n\r\n  /**\r\n   * Check if dispatching back action will be handled by navigation.\r\n   * Note that this method doesn't re-render screen when the result changes. So don't use it in `render`.\r\n   */\r\n  canGoBack(): boolean;\r\n\r\n  /**\r\n   * Returns the name of the navigator specified in the `name` prop.\r\n   * If no name is specified, returns `undefined`.\r\n   */\r\n  getId(): string | undefined;\r\n\r\n  /**\r\n   * Returns the navigation helpers from a parent navigator based on the ID.\r\n   * If an ID is provided, the navigation helper from the parent navigator with matching ID (including current) will be returned.\r\n   * If no ID is provided, the navigation helper from the immediate parent navigator will be returned.\r\n   *\r\n   * @param id Optional ID of a parent navigator.\r\n   */\r\n  getParent<T = NavigationHelpers<ParamListBase> | undefined>(id?: string): T;\r\n\r\n  /**\r\n   * Returns the navigator's state.\r\n   * Note that this method doesn't re-render screen when the result changes. So don't use it in `render`.\r\n   */\r\n  getState(): State;\r\n} & PrivateValueStore<[ParamList, unknown, unknown]>;\r\n\r\nexport type NavigationHelpers<\r\n  ParamList extends ParamListBase,\r\n  EventMap extends EventMapBase = {}\r\n> = NavigationHelpersCommon<ParamList> &\r\n  EventEmitter<EventMap> & {\r\n    /**\r\n     * Update the param object for the route.\r\n     * The new params will be shallow merged with the old one.\r\n     *\r\n     * @param params Params object for the current route.\r\n     */\r\n    setParams<RouteName extends keyof ParamList>(\r\n      params: Partial<ParamList[RouteName]>\r\n    ): void;\r\n  };\r\n\r\nexport type NavigationContainerProps = {\r\n  /**\r\n   * Initial navigation state for the child navigators.\r\n   */\r\n  initialState?: InitialState;\r\n  /**\r\n   * Callback which is called with the latest navigation state when it changes.\r\n   */\r\n  onStateChange?: (state: NavigationState | undefined) => void;\r\n  /**\r\n   * Callback which is called when an action is not handled.\r\n   */\r\n  onUnhandledAction?: (action: NavigationAction) => void;\r\n  /**\r\n   * Whether this navigation container should be independent of parent containers.\r\n   * If this is not set to `true`, this container cannot be nested inside another container.\r\n   * Setting it to `true` disconnects any children navigators from parent container.\r\n   */\r\n  independent?: boolean;\r\n  /**\r\n   * Children elements to render.\r\n   */\r\n  children: React.ReactNode;\r\n};\r\n\r\nexport type NavigationProp<\r\n  ParamList extends {},\r\n  RouteName extends keyof ParamList = Keyof<ParamList>,\r\n  NavigatorID extends string | undefined = undefined,\r\n  State extends NavigationState = NavigationState<ParamList>,\r\n  ScreenOptions extends {} = {},\r\n  EventMap extends EventMapBase = {}\r\n> = Omit<NavigationHelpersCommon<ParamList, State>, 'getParent'> & {\r\n  /**\r\n   * Returns the navigation prop from a parent navigator based on the ID.\r\n   * If an ID is provided, the navigation prop from the parent navigator with matching ID (including current) will be returned.\r\n   * If no ID is provided, the navigation prop from the immediate parent navigator will be returned.\r\n   *\r\n   * @param id Optional ID of a parent navigator.\r\n   */\r\n  getParent<T = NavigationProp<ParamListBase> | undefined>(id?: NavigatorID): T;\r\n\r\n  /**\r\n   * Update the param object for the route.\r\n   * The new params will be shallow merged with the old one.\r\n   *\r\n   * @param params Params object for the current route.\r\n   */\r\n  setParams(\r\n    params: ParamList[RouteName] extends undefined\r\n      ? undefined\r\n      : Partial<ParamList[RouteName]>\r\n  ): void;\r\n\r\n  /**\r\n   * Update the options for the route.\r\n   * The options object will be shallow merged with default options object.\r\n   *\r\n   * @param options Options object for the route.\r\n   */\r\n  setOptions(options: Partial<ScreenOptions>): void;\r\n} & EventConsumer<EventMap & EventMapCore<State>> &\r\n  PrivateValueStore<[ParamList, RouteName, EventMap]>;\r\n\r\nexport type RouteProp<\r\n  ParamList extends ParamListBase,\r\n  RouteName extends keyof ParamList = Keyof<ParamList>\r\n> = Route<Extract<RouteName, string>, ParamList[RouteName]>;\r\n\r\nexport type CompositeNavigationProp<\r\n  A extends NavigationProp<ParamListBase, string, any, any, any>,\r\n  B extends NavigationHelpersCommon<ParamListBase, any>\r\n> = Omit<A & B, keyof NavigationProp<any>> &\r\n  NavigationProp<\r\n    /**\r\n     * Param list from both navigation objects needs to be combined\r\n     * For example, we should be able to navigate to screens in both A and B\r\n     */\r\n    (A extends NavigationHelpersCommon<infer T> ? T : never) &\r\n      (B extends NavigationHelpersCommon<infer U> ? U : never),\r\n    /**\r\n     * The route name should refer to the route name specified in the first type\r\n     * Ideally it should work for any of them, but it's not possible to infer that way\r\n     */\r\n    A extends NavigationProp<any, infer R> ? R : string,\r\n    /**\r\n     * ID from both navigation objects needs to be combined for `getParent`\r\n     */\r\n    | (A extends NavigationProp<any, any, infer I> ? I : never)\r\n    | (B extends NavigationProp<any, any, infer J> ? J : never),\r\n    /**\r\n     * The type of state should refer to the state specified in the first type\r\n     */\r\n    A extends NavigationProp<any, any, any, infer S> ? S : NavigationState,\r\n    /**\r\n     * Screen options from both navigation objects needs to be combined\r\n     * This allows typechecking `setOptions`\r\n     */\r\n    (A extends NavigationProp<any, any, any, any, infer O> ? O : {}) &\r\n      (B extends NavigationProp<any, any, any, any, infer P> ? P : {}),\r\n    /**\r\n     * Event consumer config should refer to the config specified in the first type\r\n     * This allows typechecking `addListener`/`removeListener`\r\n     */\r\n    A extends NavigationProp<any, any, any, any, any, infer E> ? E : {}\r\n  >;\r\n\r\nexport type CompositeScreenProps<\r\n  A extends {\r\n    navigation: NavigationProp<\r\n      ParamListBase,\r\n      string,\r\n      string | undefined,\r\n      any,\r\n      any,\r\n      any\r\n    >;\r\n    route: RouteProp<ParamListBase>;\r\n  },\r\n  B extends {\r\n    navigation: NavigationHelpersCommon<any, any>;\r\n  }\r\n> = {\r\n  navigation: CompositeNavigationProp<A['navigation'], B['navigation']>;\r\n  route: A['route'];\r\n};\r\n\r\nexport type Descriptor<\r\n  ScreenOptions extends {},\r\n  Navigation extends NavigationProp<any, any, any, any, any, any>,\r\n  Route extends RouteProp<any, any>\r\n> = {\r\n  /**\r\n   * Render the component associated with this route.\r\n   */\r\n  render(): JSX.Element;\r\n\r\n  /**\r\n   * Options for the route.\r\n   */\r\n  options: ScreenOptions;\r\n\r\n  /**\r\n   * Route object for the screen\r\n   */\r\n  route: Route;\r\n\r\n  /**\r\n   * Navigation object for the screen\r\n   */\r\n  navigation: Navigation;\r\n};\r\n\r\nexport type ScreenListeners<\r\n  State extends NavigationState,\r\n  EventMap extends EventMapBase\r\n> = Partial<{\r\n  [EventName in keyof (EventMap & EventMapCore<State>)]: EventListenerCallback<\r\n    EventMap,\r\n    EventName\r\n  >;\r\n}>;\r\n\r\ntype ScreenComponentType<\r\n  ParamList extends ParamListBase,\r\n  RouteName extends keyof ParamList\r\n> =\r\n  | React.ComponentType<{\r\n      route: RouteProp<ParamList, RouteName>;\r\n      navigation: any;\r\n    }>\r\n  | React.ComponentType<{}>;\r\n\r\nexport type RouteConfigComponent<\r\n  ParamList extends ParamListBase,\r\n  RouteName extends keyof ParamList\r\n> =\r\n  | {\r\n      /**\r\n       * React component to render for this screen.\r\n       */\r\n      component: ScreenComponentType<ParamList, RouteName>;\r\n      getComponent?: never;\r\n      children?: never;\r\n    }\r\n  | {\r\n      /**\r\n       * Lazily get a React component to render for this screen.\r\n       */\r\n      getComponent: () => ScreenComponentType<ParamList, RouteName>;\r\n      component?: never;\r\n      children?: never;\r\n    }\r\n  | {\r\n      /**\r\n       * Render callback to render content of this screen.\r\n       */\r\n      children: (props: {\r\n        route: RouteProp<ParamList, RouteName>;\r\n        navigation: any;\r\n      }) => React.ReactNode;\r\n      component?: never;\r\n      getComponent?: never;\r\n    };\r\n\r\nexport type RouteConfig<\r\n  ParamList extends ParamListBase,\r\n  RouteName extends keyof ParamList,\r\n  State extends NavigationState,\r\n  ScreenOptions extends {},\r\n  EventMap extends EventMapBase\r\n> = {\r\n  /**\r\n   * Optional key for this screen. This doesn't need to be unique.\r\n   * If the key changes, existing screens with this name will be removed or reset.\r\n   * Useful when we have some common screens and have conditional rendering.\r\n   */\r\n  navigationKey?: string;\r\n\r\n  /**\r\n   * Route name of this screen.\r\n   */\r\n  name: RouteName;\r\n\r\n  /**\r\n   * Navigator options for this screen.\r\n   */\r\n  options?:\r\n    | ScreenOptions\r\n    | ((props: {\r\n        route: RouteProp<ParamList, RouteName>;\r\n        navigation: any;\r\n      }) => ScreenOptions);\r\n\r\n  /**\r\n   * Event listeners for this screen.\r\n   */\r\n  listeners?:\r\n    | ScreenListeners<State, EventMap>\r\n    | ((props: {\r\n        route: RouteProp<ParamList, RouteName>;\r\n        navigation: any;\r\n      }) => ScreenListeners<State, EventMap>);\r\n\r\n  /**\r\n   * Function to return an unique ID for this screen.\r\n   * Receives an object with the route params.\r\n   * For a given screen name, there will always be only one screen corresponding to an ID.\r\n   * If `undefined` is returned, it acts same as no `getId` being specified.\r\n   */\r\n  getId?: ({ params }: { params: ParamList[RouteName] }) => string | undefined;\r\n\r\n  /**\r\n   * Initial params object for the route.\r\n   */\r\n  initialParams?: Partial<ParamList[RouteName]>;\r\n} & RouteConfigComponent<ParamList, RouteName>;\r\n\r\nexport type RouteGroupConfig<\r\n  ParamList extends ParamListBase,\r\n  ScreenOptions extends {}\r\n> = {\r\n  /**\r\n   * Optional key for the screens in this group.\r\n   * If the key changes, all existing screens in this group will be removed or reset.\r\n   */\r\n  navigationKey?: string;\r\n\r\n  /**\r\n   * Navigator options for this screen.\r\n   */\r\n  screenOptions?:\r\n    | ScreenOptions\r\n    | ((props: {\r\n        route: RouteProp<ParamList, keyof ParamList>;\r\n        navigation: any;\r\n      }) => ScreenOptions);\r\n  /**\r\n   * Children React Elements to extract the route configuration from.\r\n   * Only `Screen`, `Group` and `React.Fragment` are supported as children.\r\n   */\r\n  children: React.ReactNode;\r\n};\r\n\r\nexport type NavigationContainerEventMap = {\r\n  /**\r\n   * Event which fires when the navigation state changes.\r\n   */\r\n  state: {\r\n    data: {\r\n      /**\r\n       * The updated state object after the state change.\r\n       */\r\n      state: NavigationState | PartialState<NavigationState> | undefined;\r\n    };\r\n  };\r\n  /**\r\n   * Event which fires when current options changes.\r\n   */\r\n  options: { data: { options: object } };\r\n  /**\r\n   * Event which fires when an action is dispatched.\r\n   * Only intended for debugging purposes, don't use it for app logic.\r\n   * This event will be emitted before state changes have been applied.\r\n   */\r\n  __unsafe_action__: {\r\n    data: {\r\n      /**\r\n       * The action object which was dispatched.\r\n       */\r\n      action: NavigationAction;\r\n      /**\r\n       * Whether the action was a no-op, i.e. resulted any state changes.\r\n       */\r\n      noop: boolean;\r\n      /**\r\n       * Stack trace of the action, this will only be available during development.\r\n       */\r\n      stack: string | undefined;\r\n    };\r\n  };\r\n};\r\n\r\nexport type NavigationContainerRef<ParamList extends {}> =\r\n  NavigationHelpers<ParamList> &\r\n    EventConsumer<NavigationContainerEventMap> & {\r\n      /**\r\n       * Reset the navigation state of the root navigator to the provided state.\r\n       *\r\n       * @param state Navigation state object.\r\n       */\r\n      resetRoot(state?: PartialState<NavigationState> | NavigationState): void;\r\n      /**\r\n       * Get the rehydrated navigation state of the navigation tree.\r\n       */\r\n      getRootState(): NavigationState;\r\n      /**\r\n       * Get the currently focused navigation route.\r\n       */\r\n      getCurrentRoute(): Route<string> | undefined;\r\n      /**\r\n       * Get the currently focused route's options.\r\n       */\r\n      getCurrentOptions(): object | undefined;\r\n      /**\r\n       * Whether the navigation container is ready to handle actions.\r\n       */\r\n      isReady(): boolean;\r\n    };\r\n\r\nexport type NavigationContainerRefWithCurrent<ParamList extends {}> =\r\n  NavigationContainerRef<ParamList> & {\r\n    current: NavigationContainerRef<ParamList> | null;\r\n  };\r\n\r\nexport type TypedNavigator<\r\n  ParamList extends ParamListBase,\r\n  State extends NavigationState,\r\n  ScreenOptions extends {},\r\n  EventMap extends EventMapBase,\r\n  Navigator extends React.ComponentType<any>\r\n> = {\r\n  /**\r\n   * Navigator component which manages the child screens.\r\n   */\r\n  Navigator: React.ComponentType<\r\n    Omit<\r\n      React.ComponentProps<Navigator>,\r\n      keyof DefaultNavigatorOptions<any, any, any, any>\r\n    > &\r\n      DefaultNavigatorOptions<ParamList, State, ScreenOptions, EventMap>\r\n  >;\r\n  /**\r\n   * Component used for grouping multiple route configuration.\r\n   */\r\n  Group: React.ComponentType<RouteGroupConfig<ParamList, ScreenOptions>>;\r\n  /**\r\n   * Component used for specifying route configuration.\r\n   */\r\n  Screen: <RouteName extends keyof ParamList>(\r\n    _: RouteConfig<ParamList, RouteName, State, ScreenOptions, EventMap>\r\n  ) => null;\r\n};\r\n\r\nexport type NavigatorScreenParams<\r\n  ParamList,\r\n  State extends NavigationState = NavigationState\r\n> =\r\n  | {\r\n      screen?: never;\r\n      params?: never;\r\n      initial?: never;\r\n      path?: string;\r\n      state: PartialState<State> | State | undefined;\r\n    }\r\n  | {\r\n      [RouteName in keyof ParamList]: undefined extends ParamList[RouteName]\r\n        ? {\r\n            screen: RouteName;\r\n            params?: ParamList[RouteName];\r\n            initial?: boolean;\r\n            path?: string;\r\n            state?: never;\r\n          }\r\n        : {\r\n            screen: RouteName;\r\n            params: ParamList[RouteName];\r\n            initial?: boolean;\r\n            path?: string;\r\n            state?: never;\r\n          };\r\n    }[keyof ParamList];\r\n\r\nexport type PathConfig<ParamList extends {}> = {\r\n  path?: string;\r\n  exact?: boolean;\r\n  parse?: Record<string, (value: string) => any>;\r\n  stringify?: Record<string, (value: any) => string>;\r\n  screens?: PathConfigMap<ParamList>;\r\n  initialRouteName?: keyof ParamList;\r\n};\r\n\r\nexport type PathConfigMap<ParamList extends {}> = {\r\n  [RouteName in keyof ParamList]?: NonNullable<\r\n    ParamList[RouteName]\r\n  > extends NavigatorScreenParams<infer T extends {}>\r\n    ? string | PathConfig<T>\r\n    : string | Omit<PathConfig<{}>, 'screens' | 'initialRouteName'>;\r\n};\r\n"],"mappings":";;AAoJA,WAAaA,iBAAiB,GAAAC,YAAA,UAAAD,kBAAA;EAAAE,eAAA,OAAAF,iBAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}