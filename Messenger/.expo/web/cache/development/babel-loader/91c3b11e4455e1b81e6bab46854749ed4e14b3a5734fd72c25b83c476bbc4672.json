{"ast":null,"code":"import { isColor, convertToRGBA, rgbaArrayToRGBAColor, toGammaSpace, toLinearSpace } from \"../Colors\";\nimport { ReduceMotion } from \"../commonTypes\";\nimport NativeReanimatedModule from \"../NativeReanimated\";\nimport { flatten, multiplyMatrices, scaleMatrix, addMatrices, decomposeMatrixIntoMatricesAndAngles, isAffineMatrixFlat, subtractMatrices, getRotationMatrix } from \"./transformationMatrix/matrixUtils\";\nimport { isReducedMotion } from \"../PlatformChecker\";\nvar IN_STYLE_UPDATER = false;\nvar IS_REDUCED_MOTION = isReducedMotion();\nexport function initialUpdaterRun(updater) {\n  IN_STYLE_UPDATER = true;\n  var result = updater();\n  IN_STYLE_UPDATER = false;\n  return result;\n}\nfunction recognizePrefixSuffix(value) {\n  'worklet';\n\n  if (typeof value === 'string') {\n    var _match$;\n    var match = value.match(/([A-Za-z]*)(-?\\d*\\.?\\d*)([eE][-+]?[0-9]+)?([A-Za-z%]*)/);\n    if (!match) {\n      throw new Error(\"[Reanimated] Couldn't parse animation value.\");\n    }\n    var prefix = match[1];\n    var suffix = match[4];\n    var number = match[2] + ((_match$ = match[3]) != null ? _match$ : '');\n    return {\n      prefix: prefix,\n      suffix: suffix,\n      strippedValue: parseFloat(number)\n    };\n  } else {\n    return {\n      strippedValue: value\n    };\n  }\n}\nexport function getReduceMotionFromConfig(config) {\n  'worklet';\n\n  return !config || config === ReduceMotion.System ? IS_REDUCED_MOTION : config === ReduceMotion.Always;\n}\nexport function getReduceMotionForAnimation(config) {\n  'worklet';\n  if (!config) {\n    return undefined;\n  }\n  return getReduceMotionFromConfig(config);\n}\nfunction applyProgressToMatrix(progress, a, b) {\n  'worklet';\n\n  return addMatrices(a, scaleMatrix(subtractMatrices(b, a), progress));\n}\nfunction applyProgressToNumber(progress, a, b) {\n  'worklet';\n\n  return a + progress * (b - a);\n}\nfunction decorateAnimation(animation) {\n  'worklet';\n\n  var baseOnStart = animation.onStart;\n  var baseOnFrame = animation.onFrame;\n  if (animation.isHigherOrder) {\n    animation.onStart = function (animation, value, timestamp, previousAnimation) {\n      if (animation.reduceMotion === undefined) {\n        animation.reduceMotion = getReduceMotionFromConfig();\n      }\n      return baseOnStart(animation, value, timestamp, previousAnimation);\n    };\n    return;\n  }\n  var animationCopy = Object.assign({}, animation);\n  delete animationCopy.callback;\n  var prefNumberSuffOnStart = function prefNumberSuffOnStart(animation, value, timestamp, previousAnimation) {\n    var _animation$__prefix, _animation$__suffix;\n    var _recognizePrefixSuffi = recognizePrefixSuffix(value),\n      prefix = _recognizePrefixSuffi.prefix,\n      suffix = _recognizePrefixSuffi.suffix,\n      strippedValue = _recognizePrefixSuffi.strippedValue;\n    animation.__prefix = prefix;\n    animation.__suffix = suffix;\n    animation.strippedCurrent = strippedValue;\n    var _recognizePrefixSuffi2 = recognizePrefixSuffix(animation.toValue),\n      strippedToValue = _recognizePrefixSuffi2.strippedValue;\n    animation.current = strippedValue;\n    animation.startValue = strippedValue;\n    animation.toValue = strippedToValue;\n    if (previousAnimation && previousAnimation !== animation) {\n      var _recognizePrefixSuffi3 = recognizePrefixSuffix(previousAnimation.current),\n        paPrefix = _recognizePrefixSuffi3.prefix,\n        paSuffix = _recognizePrefixSuffi3.suffix,\n        paStrippedValue = _recognizePrefixSuffi3.strippedValue;\n      previousAnimation.current = paStrippedValue;\n      previousAnimation.__prefix = paPrefix;\n      previousAnimation.__suffix = paSuffix;\n    }\n    baseOnStart(animation, strippedValue, timestamp, previousAnimation);\n    animation.current = ((_animation$__prefix = animation.__prefix) != null ? _animation$__prefix : '') + animation.current + ((_animation$__suffix = animation.__suffix) != null ? _animation$__suffix : '');\n    if (previousAnimation && previousAnimation !== animation) {\n      var _previousAnimation$__, _previousAnimation$__2;\n      previousAnimation.current = ((_previousAnimation$__ = previousAnimation.__prefix) != null ? _previousAnimation$__ : '') + previousAnimation.current + ((_previousAnimation$__2 = previousAnimation.__suffix) != null ? _previousAnimation$__2 : '');\n    }\n  };\n  var prefNumberSuffOnFrame = function prefNumberSuffOnFrame(animation, timestamp) {\n    var _animation$__prefix2, _animation$__suffix2;\n    animation.current = animation.strippedCurrent;\n    var res = baseOnFrame(animation, timestamp);\n    animation.strippedCurrent = animation.current;\n    animation.current = ((_animation$__prefix2 = animation.__prefix) != null ? _animation$__prefix2 : '') + animation.current + ((_animation$__suffix2 = animation.__suffix) != null ? _animation$__suffix2 : '');\n    return res;\n  };\n  var tab = ['R', 'G', 'B', 'A'];\n  var colorOnStart = function colorOnStart(animation, value, timestamp, previousAnimation) {\n    var RGBAValue;\n    var RGBACurrent;\n    var RGBAToValue;\n    var res = [];\n    if (isColor(value)) {\n      RGBACurrent = toLinearSpace(convertToRGBA(animation.current));\n      RGBAValue = toLinearSpace(convertToRGBA(value));\n      if (animation.toValue) {\n        RGBAToValue = toLinearSpace(convertToRGBA(animation.toValue));\n      }\n    }\n    tab.forEach(function (i, index) {\n      animation[i] = Object.assign({}, animationCopy);\n      animation[i].current = RGBACurrent[index];\n      animation[i].toValue = RGBAToValue ? RGBAToValue[index] : undefined;\n      animation[i].onStart(animation[i], RGBAValue[index], timestamp, previousAnimation ? previousAnimation[i] : undefined);\n      res.push(animation[i].current);\n    });\n    animation.current = rgbaArrayToRGBAColor(toGammaSpace(res));\n  };\n  var colorOnFrame = function colorOnFrame(animation, timestamp) {\n    var RGBACurrent = toLinearSpace(convertToRGBA(animation.current));\n    var res = [];\n    var finished = true;\n    tab.forEach(function (i, index) {\n      animation[i].current = RGBACurrent[index];\n      var result = animation[i].onFrame(animation[i], timestamp);\n      finished = finished && result;\n      res.push(animation[i].current);\n    });\n    animation.current = rgbaArrayToRGBAColor(toGammaSpace(res));\n    return finished;\n  };\n  var transformationMatrixOnStart = function transformationMatrixOnStart(animation, value, timestamp, previousAnimation) {\n    var toValue = animation.toValue;\n    animation.startMatrices = decomposeMatrixIntoMatricesAndAngles(value);\n    animation.stopMatrices = decomposeMatrixIntoMatricesAndAngles(toValue);\n    animation[0] = Object.assign({}, animationCopy);\n    animation[0].current = 0;\n    animation[0].toValue = 100;\n    animation[0].onStart(animation[0], 0, timestamp, previousAnimation ? previousAnimation[0] : undefined);\n    animation.current = value;\n  };\n  var transformationMatrixOnFrame = function transformationMatrixOnFrame(animation, timestamp) {\n    var finished = true;\n    var result = animation[0].onFrame(animation[0], timestamp);\n    finished = finished && result;\n    var progress = animation[0].current / 100;\n    var transforms = ['translationMatrix', 'scaleMatrix', 'skewMatrix'];\n    var mappedTransforms = [];\n    transforms.forEach(function (key, _) {\n      return mappedTransforms.push(applyProgressToMatrix(progress, animation.startMatrices[key], animation.stopMatrices[key]));\n    });\n    var currentTranslation = mappedTransforms[0],\n      currentScale = mappedTransforms[1],\n      skewMatrix = mappedTransforms[2];\n    var rotations = ['x', 'y', 'z'];\n    var mappedRotations = [];\n    rotations.forEach(function (key, _) {\n      var angle = applyProgressToNumber(progress, animation.startMatrices['r' + key], animation.stopMatrices['r' + key]);\n      mappedRotations.push(getRotationMatrix(angle, key));\n    });\n    var rotationMatrixX = mappedRotations[0],\n      rotationMatrixY = mappedRotations[1],\n      rotationMatrixZ = mappedRotations[2];\n    var rotationMatrix = multiplyMatrices(rotationMatrixX, multiplyMatrices(rotationMatrixY, rotationMatrixZ));\n    var updated = flatten(multiplyMatrices(multiplyMatrices(currentScale, multiplyMatrices(skewMatrix, rotationMatrix)), currentTranslation));\n    animation.current = updated;\n    return finished;\n  };\n  var arrayOnStart = function arrayOnStart(animation, value, timestamp, previousAnimation) {\n    value.forEach(function (v, i) {\n      animation[i] = Object.assign({}, animationCopy);\n      animation[i].current = v;\n      animation[i].toValue = animation.toValue[i];\n      animation[i].onStart(animation[i], v, timestamp, previousAnimation ? previousAnimation[i] : undefined);\n    });\n    animation.current = value;\n  };\n  var arrayOnFrame = function arrayOnFrame(animation, timestamp) {\n    var finished = true;\n    animation.current.forEach(function (_, i) {\n      var result = animation[i].onFrame(animation[i], timestamp);\n      finished = finished && result;\n      animation.current[i] = animation[i].current;\n    });\n    return finished;\n  };\n  var objectOnStart = function objectOnStart(animation, value, timestamp, previousAnimation) {\n    for (var key in value) {\n      animation[key] = Object.assign({}, animationCopy);\n      animation[key].onStart = animation.onStart;\n      animation[key].current = value[key];\n      animation[key].toValue = animation.toValue[key];\n      animation[key].onStart(animation[key], value[key], timestamp, previousAnimation ? previousAnimation[key] : undefined);\n    }\n    animation.current = value;\n  };\n  var objectOnFrame = function objectOnFrame(animation, timestamp) {\n    var finished = true;\n    var newObject = {};\n    for (var key in animation.current) {\n      var result = animation[key].onFrame(animation[key], timestamp);\n      finished = finished && result;\n      newObject[key] = animation[key].current;\n    }\n    animation.current = newObject;\n    return finished;\n  };\n  animation.onStart = function (animation, value, timestamp, previousAnimation) {\n    if (animation.reduceMotion === undefined) {\n      animation.reduceMotion = getReduceMotionFromConfig();\n    }\n    if (animation.reduceMotion) {\n      if (animation.toValue !== undefined) {\n        animation.current = animation.toValue;\n      } else {\n        baseOnStart(animation, value, timestamp, previousAnimation);\n      }\n      animation.startTime = 0;\n      animation.onFrame = function () {\n        return true;\n      };\n      return;\n    }\n    if (isColor(value)) {\n      colorOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = colorOnFrame;\n      return;\n    } else if (isAffineMatrixFlat(value)) {\n      transformationMatrixOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = transformationMatrixOnFrame;\n      return;\n    } else if (Array.isArray(value)) {\n      arrayOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = arrayOnFrame;\n      return;\n    } else if (typeof value === 'string') {\n      prefNumberSuffOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = prefNumberSuffOnFrame;\n      return;\n    } else if (typeof value === 'object' && value !== null) {\n      objectOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = objectOnFrame;\n      return;\n    }\n    baseOnStart(animation, value, timestamp, previousAnimation);\n  };\n}\nvar IS_NATIVE = NativeReanimatedModule.native;\nexport function defineAnimation(starting, factory) {\n  'worklet';\n\n  if (IN_STYLE_UPDATER) {\n    return starting;\n  }\n  var create = function create() {\n    'worklet';\n\n    var animation = factory();\n    decorateAnimation(animation);\n    return animation;\n  };\n  if (_WORKLET || !IS_NATIVE) {\n    return create();\n  }\n  return create;\n}\nexport function cancelAnimation(sharedValue) {\n  'worklet';\n  sharedValue.value = sharedValue.value;\n}","map":{"version":3,"names":["isColor","convertToRGBA","rgbaArrayToRGBAColor","toGammaSpace","toLinearSpace","ReduceMotion","NativeReanimatedModule","flatten","multiplyMatrices","scaleMatrix","addMatrices","decomposeMatrixIntoMatricesAndAngles","isAffineMatrixFlat","subtractMatrices","getRotationMatrix","isReducedMotion","IN_STYLE_UPDATER","IS_REDUCED_MOTION","initialUpdaterRun","updater","result","recognizePrefixSuffix","value","_match$","match","Error","prefix","suffix","number","strippedValue","parseFloat","getReduceMotionFromConfig","config","System","Always","getReduceMotionForAnimation","undefined","applyProgressToMatrix","progress","a","b","applyProgressToNumber","decorateAnimation","animation","baseOnStart","onStart","baseOnFrame","onFrame","isHigherOrder","timestamp","previousAnimation","reduceMotion","animationCopy","Object","assign","callback","prefNumberSuffOnStart","_animation$__prefix","_animation$__suffix","_recognizePrefixSuffi","__prefix","__suffix","strippedCurrent","_recognizePrefixSuffi2","toValue","strippedToValue","current","startValue","_recognizePrefixSuffi3","paPrefix","paSuffix","paStrippedValue","_previousAnimation$__","_previousAnimation$__2","prefNumberSuffOnFrame","_animation$__prefix2","_animation$__suffix2","res","tab","colorOnStart","RGBAValue","RGBACurrent","RGBAToValue","forEach","i","index","push","colorOnFrame","finished","transformationMatrixOnStart","startMatrices","stopMatrices","transformationMatrixOnFrame","transforms","mappedTransforms","key","_","currentTranslation","currentScale","skewMatrix","rotations","mappedRotations","angle","rotationMatrixX","rotationMatrixY","rotationMatrixZ","rotationMatrix","updated","arrayOnStart","v","arrayOnFrame","objectOnStart","objectOnFrame","newObject","startTime","Array","isArray","IS_NATIVE","native","defineAnimation","starting","factory","create","_WORKLET","cancelAnimation","sharedValue"],"sources":["C:\\Users\\Admin\\Project\\Project\\Messenger\\Messenger\\node_modules\\react-native-reanimated\\lib\\module\\reanimated2\\animation\\util.ts"],"sourcesContent":["import type { HigherOrderAnimation, StyleLayoutAnimation } from './commonTypes';\nimport type { ParsedColorArray } from '../Colors';\nimport {\n  isColor,\n  convertToRGBA,\n  rgbaArrayToRGBAColor,\n  toGammaSpace,\n  toLinearSpace,\n} from '../Colors';\nimport { ReduceMotion } from '../commonTypes';\nimport type {\n  SharedValue,\n  AnimatableValue,\n  Animation,\n  AnimationObject,\n  Timestamp,\n  AnimatableValueObject,\n} from '../commonTypes';\nimport NativeReanimatedModule from '../NativeReanimated';\nimport type {\n  AffineMatrixFlat,\n  AffineMatrix,\n} from './transformationMatrix/matrixUtils';\nimport {\n  flatten,\n  multiplyMatrices,\n  scaleMatrix,\n  addMatrices,\n  decomposeMatrixIntoMatricesAndAngles,\n  isAffineMatrixFlat,\n  subtractMatrices,\n  getRotationMatrix,\n} from './transformationMatrix/matrixUtils';\nimport { isReducedMotion } from '../PlatformChecker';\n\nlet IN_STYLE_UPDATER = false;\nconst IS_REDUCED_MOTION = isReducedMotion();\n\nexport function initialUpdaterRun<T>(updater: () => T) {\n  IN_STYLE_UPDATER = true;\n  const result = updater();\n  IN_STYLE_UPDATER = false;\n  return result;\n}\n\ninterface RecognizedPrefixSuffix {\n  prefix?: string;\n  suffix?: string;\n  strippedValue: number;\n}\n\nfunction recognizePrefixSuffix(value: string | number): RecognizedPrefixSuffix {\n  'worklet';\n  if (typeof value === 'string') {\n    const match = value.match(\n      /([A-Za-z]*)(-?\\d*\\.?\\d*)([eE][-+]?[0-9]+)?([A-Za-z%]*)/\n    );\n    if (!match) {\n      throw new Error(\"[Reanimated] Couldn't parse animation value.\");\n    }\n    const prefix = match[1];\n    const suffix = match[4];\n    // number with scientific notation\n    const number = match[2] + (match[3] ?? '');\n    return { prefix, suffix, strippedValue: parseFloat(number) };\n  } else {\n    return { strippedValue: value };\n  }\n}\n\n/**\n * Returns whether the motion should be reduced for a specified config.\n * By default returns the system setting.\n */\nexport function getReduceMotionFromConfig(config?: ReduceMotion) {\n  'worklet';\n  return !config || config === ReduceMotion.System\n    ? IS_REDUCED_MOTION\n    : config === ReduceMotion.Always;\n}\n\n/**\n * Returns the value that should be assigned to `animation.reduceMotion`\n * for a given config. If the config is not defined, `undefined` is returned.\n */\nexport function getReduceMotionForAnimation(config?: ReduceMotion) {\n  'worklet';\n  // if the config is not defined, we want `reduceMotion` to be undefined,\n  // so the parent animation knows if it should overwrite it\n  if (!config) {\n    return undefined;\n  }\n\n  return getReduceMotionFromConfig(config);\n}\n\nfunction applyProgressToMatrix(\n  progress: number,\n  a: AffineMatrix,\n  b: AffineMatrix\n) {\n  'worklet';\n  return addMatrices(a, scaleMatrix(subtractMatrices(b, a), progress));\n}\n\nfunction applyProgressToNumber(progress: number, a: number, b: number) {\n  'worklet';\n  return a + progress * (b - a);\n}\n\nfunction decorateAnimation<T extends AnimationObject | StyleLayoutAnimation>(\n  animation: T\n): void {\n  'worklet';\n  const baseOnStart = (animation as Animation<AnimationObject>).onStart;\n  const baseOnFrame = (animation as Animation<AnimationObject>).onFrame;\n\n  if ((animation as HigherOrderAnimation).isHigherOrder) {\n    animation.onStart = (\n      animation: Animation<AnimationObject>,\n      value: number,\n      timestamp: Timestamp,\n      previousAnimation: Animation<AnimationObject>\n    ) => {\n      if (animation.reduceMotion === undefined) {\n        animation.reduceMotion = getReduceMotionFromConfig();\n      }\n      return baseOnStart(animation, value, timestamp, previousAnimation);\n    };\n    return;\n  }\n\n  const animationCopy = Object.assign({}, animation);\n  delete animationCopy.callback;\n\n  const prefNumberSuffOnStart = (\n    animation: Animation<AnimationObject>,\n    value: string | number,\n    timestamp: number,\n    previousAnimation: Animation<AnimationObject>\n  ) => {\n    // recognize prefix, suffix, and updates stripped value on animation start\n    const { prefix, suffix, strippedValue } = recognizePrefixSuffix(value);\n    animation.__prefix = prefix;\n    animation.__suffix = suffix;\n    animation.strippedCurrent = strippedValue;\n    const { strippedValue: strippedToValue } = recognizePrefixSuffix(\n      animation.toValue as string | number\n    );\n    animation.current = strippedValue;\n    animation.startValue = strippedValue;\n    animation.toValue = strippedToValue;\n    if (previousAnimation && previousAnimation !== animation) {\n      const {\n        prefix: paPrefix,\n        suffix: paSuffix,\n        strippedValue: paStrippedValue,\n      } = recognizePrefixSuffix(previousAnimation.current as string | number);\n      previousAnimation.current = paStrippedValue;\n      previousAnimation.__prefix = paPrefix;\n      previousAnimation.__suffix = paSuffix;\n    }\n\n    baseOnStart(animation, strippedValue, timestamp, previousAnimation);\n\n    animation.current =\n      (animation.__prefix ?? '') +\n      animation.current +\n      (animation.__suffix ?? '');\n\n    if (previousAnimation && previousAnimation !== animation) {\n      previousAnimation.current =\n        (previousAnimation.__prefix ?? '') +\n        previousAnimation.current +\n        (previousAnimation.__suffix ?? '');\n    }\n  };\n  const prefNumberSuffOnFrame = (\n    animation: Animation<AnimationObject>,\n    timestamp: number\n  ) => {\n    animation.current = animation.strippedCurrent;\n    const res = baseOnFrame(animation, timestamp);\n    animation.strippedCurrent = animation.current;\n    animation.current =\n      (animation.__prefix ?? '') +\n      animation.current +\n      (animation.__suffix ?? '');\n    return res;\n  };\n\n  const tab = ['R', 'G', 'B', 'A'];\n  const colorOnStart = (\n    animation: Animation<AnimationObject>,\n    value: string | number,\n    timestamp: Timestamp,\n    previousAnimation: Animation<AnimationObject>\n  ): void => {\n    let RGBAValue: ParsedColorArray;\n    let RGBACurrent: ParsedColorArray;\n    let RGBAToValue: ParsedColorArray;\n    const res: Array<number> = [];\n    if (isColor(value)) {\n      RGBACurrent = toLinearSpace(convertToRGBA(animation.current));\n      RGBAValue = toLinearSpace(convertToRGBA(value));\n      if (animation.toValue) {\n        RGBAToValue = toLinearSpace(convertToRGBA(animation.toValue));\n      }\n    }\n    tab.forEach((i, index) => {\n      animation[i] = Object.assign({}, animationCopy);\n      animation[i].current = RGBACurrent[index];\n      animation[i].toValue = RGBAToValue ? RGBAToValue[index] : undefined;\n      animation[i].onStart(\n        animation[i],\n        RGBAValue[index],\n        timestamp,\n        previousAnimation ? previousAnimation[i] : undefined\n      );\n      res.push(animation[i].current);\n    });\n\n    animation.current = rgbaArrayToRGBAColor(\n      toGammaSpace(res as ParsedColorArray)\n    );\n  };\n\n  const colorOnFrame = (\n    animation: Animation<AnimationObject>,\n    timestamp: Timestamp\n  ): boolean => {\n    const RGBACurrent = toLinearSpace(convertToRGBA(animation.current));\n    const res: Array<number> = [];\n    let finished = true;\n    tab.forEach((i, index) => {\n      animation[i].current = RGBACurrent[index];\n      const result = animation[i].onFrame(animation[i], timestamp);\n      // We really need to assign this value to result, instead of passing it directly - otherwise once \"finished\" is false, onFrame won't be called\n      finished = finished && result;\n      res.push(animation[i].current);\n    });\n\n    animation.current = rgbaArrayToRGBAColor(\n      toGammaSpace(res as ParsedColorArray)\n    );\n    return finished;\n  };\n\n  const transformationMatrixOnStart = (\n    animation: Animation<AnimationObject>,\n    value: AffineMatrixFlat,\n    timestamp: Timestamp,\n    previousAnimation: Animation<AnimationObject>\n  ): void => {\n    const toValue = animation.toValue as AffineMatrixFlat;\n\n    animation.startMatrices = decomposeMatrixIntoMatricesAndAngles(value);\n    animation.stopMatrices = decomposeMatrixIntoMatricesAndAngles(toValue);\n\n    // We create an animation copy to animate single value between 0 and 100\n    // We set limits from 0 to 100 (instead of 0-1) to make spring look good\n    // with default thresholds.\n\n    animation[0] = Object.assign({}, animationCopy);\n    animation[0].current = 0;\n    animation[0].toValue = 100;\n    animation[0].onStart(\n      animation[0],\n      0,\n      timestamp,\n      previousAnimation ? previousAnimation[0] : undefined\n    );\n\n    animation.current = value;\n  };\n\n  const transformationMatrixOnFrame = (\n    animation: Animation<AnimationObject>,\n    timestamp: Timestamp\n  ): boolean => {\n    let finished = true;\n    const result = animation[0].onFrame(animation[0], timestamp);\n    // We really need to assign this value to result, instead of passing it directly - otherwise once \"finished\" is false, onFrame won't be called\n    finished = finished && result;\n\n    const progress = animation[0].current / 100;\n\n    const transforms = ['translationMatrix', 'scaleMatrix', 'skewMatrix'];\n    const mappedTransforms: Array<AffineMatrix> = [];\n\n    transforms.forEach((key, _) =>\n      mappedTransforms.push(\n        applyProgressToMatrix(\n          progress,\n          animation.startMatrices[key],\n          animation.stopMatrices[key]\n        )\n      )\n    );\n\n    const [currentTranslation, currentScale, skewMatrix] = mappedTransforms;\n\n    const rotations: Array<'x' | 'y' | 'z'> = ['x', 'y', 'z'];\n    const mappedRotations: Array<AffineMatrix> = [];\n\n    rotations.forEach((key, _) => {\n      const angle = applyProgressToNumber(\n        progress,\n        animation.startMatrices['r' + key],\n        animation.stopMatrices['r' + key]\n      );\n      mappedRotations.push(getRotationMatrix(angle, key));\n    });\n\n    const [rotationMatrixX, rotationMatrixY, rotationMatrixZ] = mappedRotations;\n\n    const rotationMatrix = multiplyMatrices(\n      rotationMatrixX,\n      multiplyMatrices(rotationMatrixY, rotationMatrixZ)\n    );\n\n    const updated = flatten(\n      multiplyMatrices(\n        multiplyMatrices(\n          currentScale,\n          multiplyMatrices(skewMatrix, rotationMatrix)\n        ),\n        currentTranslation\n      )\n    );\n\n    animation.current = updated;\n\n    return finished;\n  };\n\n  const arrayOnStart = (\n    animation: Animation<AnimationObject>,\n    value: Array<number>,\n    timestamp: Timestamp,\n    previousAnimation: Animation<AnimationObject>\n  ): void => {\n    value.forEach((v, i) => {\n      animation[i] = Object.assign({}, animationCopy);\n      animation[i].current = v;\n      animation[i].toValue = (animation.toValue as Array<number>)[i];\n      animation[i].onStart(\n        animation[i],\n        v,\n        timestamp,\n        previousAnimation ? previousAnimation[i] : undefined\n      );\n    });\n\n    animation.current = value;\n  };\n\n  const arrayOnFrame = (\n    animation: Animation<AnimationObject>,\n    timestamp: Timestamp\n  ): boolean => {\n    let finished = true;\n    (animation.current as Array<number>).forEach((_, i) => {\n      const result = animation[i].onFrame(animation[i], timestamp);\n      // We really need to assign this value to result, instead of passing it directly - otherwise once \"finished\" is false, onFrame won't be called\n      finished = finished && result;\n      (animation.current as Array<number>)[i] = animation[i].current;\n    });\n\n    return finished;\n  };\n\n  const objectOnStart = (\n    animation: Animation<AnimationObject>,\n    value: AnimatableValueObject,\n    timestamp: Timestamp,\n    previousAnimation: Animation<AnimationObject>\n  ): void => {\n    for (const key in value) {\n      animation[key] = Object.assign({}, animationCopy);\n      animation[key].onStart = animation.onStart;\n\n      animation[key].current = value[key];\n      animation[key].toValue = (animation.toValue as AnimatableValueObject)[\n        key\n      ];\n      animation[key].onStart(\n        animation[key],\n        value[key],\n        timestamp,\n        previousAnimation ? previousAnimation[key] : undefined\n      );\n    }\n    animation.current = value;\n  };\n\n  const objectOnFrame = (\n    animation: Animation<AnimationObject>,\n    timestamp: Timestamp\n  ): boolean => {\n    let finished = true;\n    const newObject: AnimatableValueObject = {};\n    for (const key in animation.current as AnimatableValueObject) {\n      const result = animation[key].onFrame(animation[key], timestamp);\n      // We really need to assign this value to result, instead of passing it directly - otherwise once \"finished\" is false, onFrame won't be called\n      finished = finished && result;\n      newObject[key] = animation[key].current;\n    }\n    animation.current = newObject;\n    return finished;\n  };\n\n  animation.onStart = (\n    animation: Animation<AnimationObject>,\n    value: number,\n    timestamp: Timestamp,\n    previousAnimation: Animation<AnimationObject>\n  ) => {\n    if (animation.reduceMotion === undefined) {\n      animation.reduceMotion = getReduceMotionFromConfig();\n    }\n    if (animation.reduceMotion) {\n      if (animation.toValue !== undefined) {\n        animation.current = animation.toValue;\n      } else {\n        // if there is no `toValue`, then the base function is responsible for setting the current value\n        baseOnStart(animation, value, timestamp, previousAnimation);\n      }\n      animation.startTime = 0;\n      animation.onFrame = () => true;\n      return;\n    }\n    if (isColor(value)) {\n      colorOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = colorOnFrame;\n      return;\n    } else if (isAffineMatrixFlat(value)) {\n      transformationMatrixOnStart(\n        animation,\n        value,\n        timestamp,\n        previousAnimation\n      );\n      animation.onFrame = transformationMatrixOnFrame;\n      return;\n    } else if (Array.isArray(value)) {\n      arrayOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = arrayOnFrame;\n      return;\n    } else if (typeof value === 'string') {\n      prefNumberSuffOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = prefNumberSuffOnFrame;\n      return;\n    } else if (typeof value === 'object' && value !== null) {\n      objectOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = objectOnFrame;\n      return;\n    }\n    baseOnStart(animation, value, timestamp, previousAnimation);\n  };\n}\n\ntype AnimationToDecoration<\n  T extends AnimationObject | StyleLayoutAnimation,\n  U extends AnimationObject | StyleLayoutAnimation\n> = T extends StyleLayoutAnimation\n  ? Record<string, unknown>\n  : U | (() => U) | AnimatableValue;\n\nconst IS_NATIVE = NativeReanimatedModule.native;\n\nexport function defineAnimation<\n  T extends AnimationObject | StyleLayoutAnimation, // type that's supposed to be returned\n  U extends AnimationObject | StyleLayoutAnimation = T // type that's received\n>(starting: AnimationToDecoration<T, U>, factory: () => T): T {\n  'worklet';\n  if (IN_STYLE_UPDATER) {\n    return starting as unknown as T;\n  }\n  const create = () => {\n    'worklet';\n    const animation = factory();\n    decorateAnimation<U>(animation as unknown as U);\n    return animation;\n  };\n\n  if (_WORKLET || !IS_NATIVE) {\n    return create();\n  }\n  // @ts-ignore: eslint-disable-line\n  return create;\n}\n\nexport function cancelAnimation<T>(sharedValue: SharedValue<T>): void {\n  'worklet';\n  // setting the current value cancels the animation if one is currently running\n  sharedValue.value = sharedValue.value; // eslint-disable-line no-self-assign\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}