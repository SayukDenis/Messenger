{"ast":null,"code":"var DEG_TO_RAD = Math.PI / 180;\nexport var identity = [1, 0, 0, 1, 0, 0];\nvar a = 1;\nvar b = 0;\nvar c = 0;\nvar d = 1;\nvar tx = 0;\nvar ty = 0;\nvar hasInitialState = true;\nexport function reset() {\n  if (hasInitialState) {\n    return;\n  }\n  a = d = 1;\n  b = c = tx = ty = 0;\n  hasInitialState = true;\n}\nexport function toArray() {\n  if (hasInitialState) {\n    return identity;\n  }\n  return [a, b, c, d, tx, ty];\n}\nexport function append(a2, b2, c2, d2, tx2, ty2) {\n  var change = a2 !== 1 || b2 !== 0 || c2 !== 0 || d2 !== 1;\n  var translate = tx2 !== 0 || ty2 !== 0;\n  if (!change && !translate) {\n    return;\n  }\n  if (hasInitialState) {\n    hasInitialState = false;\n    a = a2;\n    b = b2;\n    c = c2;\n    d = d2;\n    tx = tx2;\n    ty = ty2;\n    return;\n  }\n  var a1 = a;\n  var b1 = b;\n  var c1 = c;\n  var d1 = d;\n  if (change) {\n    a = a1 * a2 + c1 * b2;\n    b = b1 * a2 + d1 * b2;\n    c = a1 * c2 + c1 * d2;\n    d = b1 * c2 + d1 * d2;\n  }\n  if (translate) {\n    tx = a1 * tx2 + c1 * ty2 + tx;\n    ty = b1 * tx2 + d1 * ty2 + ty;\n  }\n}\nexport function appendTransform(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\n  if (x === 0 && y === 0 && scaleX === 1 && scaleY === 1 && rotation === 0 && skewX === 0 && skewY === 0 && regX === 0 && regY === 0) {\n    return;\n  }\n  var cos, sin;\n  if (rotation % 360) {\n    var r = rotation * DEG_TO_RAD;\n    cos = Math.cos(r);\n    sin = Math.sin(r);\n  } else {\n    cos = 1;\n    sin = 0;\n  }\n  var a2 = cos * scaleX;\n  var b2 = sin * scaleX;\n  var c2 = -sin * scaleY;\n  var d2 = cos * scaleY;\n  if (skewX || skewY) {\n    var b1 = Math.tan(skewY * DEG_TO_RAD);\n    var c1 = Math.tan(skewX * DEG_TO_RAD);\n    append(a2 + c1 * b2, b1 * a2 + b2, c2 + c1 * d2, b1 * c2 + d2, x, y);\n  } else {\n    append(a2, b2, c2, d2, x, y);\n  }\n  if (regX || regY) {\n    tx -= regX * a + regY * c;\n    ty -= regX * b + regY * d;\n    hasInitialState = false;\n  }\n}","map":{"version":3,"names":["DEG_TO_RAD","Math","PI","identity","a","b","c","d","tx","ty","hasInitialState","reset","toArray","append","a2","b2","c2","d2","tx2","ty2","change","translate","a1","b1","c1","d1","appendTransform","x","y","scaleX","scaleY","rotation","skewX","skewY","regX","regY","cos","sin","r","tan"],"sources":["D:\\repo\\Messenger\\Messenger\\node_modules\\react-native-svg\\src\\lib\\Matrix2D.ts"],"sourcesContent":["/**\r\n * based on\r\n * https://github.com/CreateJS/EaselJS/blob/631cdffb85eff9413dab43b4676f059b4232d291/src/easeljs/geom/Matrix2D.js\r\n */\r\nconst DEG_TO_RAD = Math.PI / 180;\r\n\r\nexport const identity: [number, number, number, number, number, number] = [\r\n  1, 0, 0, 1, 0, 0,\r\n];\r\n\r\nlet a = 1;\r\nlet b = 0;\r\nlet c = 0;\r\nlet d = 1;\r\nlet tx = 0;\r\nlet ty = 0;\r\nlet hasInitialState = true;\r\n\r\n/**\r\n * Represents an affine transformation matrix, and provides tools for concatenating transforms.\r\n *\r\n * This matrix can be visualized as:\r\n *\r\n * \t[ a  c  tx\r\n * \t  b  d  ty\r\n * \t  0  0  1  ]\r\n *\r\n * Note the locations of b and c.\r\n **/\r\n\r\n/**\r\n * Reset current matrix to an identity matrix.\r\n * @method reset\r\n **/\r\nexport function reset() {\r\n  if (hasInitialState) {\r\n    return;\r\n  }\r\n  a = d = 1;\r\n  b = c = tx = ty = 0;\r\n  hasInitialState = true;\r\n}\r\n\r\n/**\r\n * Returns an array with current matrix values.\r\n * @method toArray\r\n * @return {Array} an array with current matrix values.\r\n **/\r\nexport function toArray(): [number, number, number, number, number, number] {\r\n  if (hasInitialState) {\r\n    return identity;\r\n  }\r\n  return [a, b, c, d, tx, ty];\r\n}\r\n\r\n/**\r\n * Appends the specified matrix properties to this matrix. All parameters are required.\r\n * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.\r\n * @method append\r\n * @param {Number} a2\r\n * @param {Number} b2\r\n * @param {Number} c2\r\n * @param {Number} d2\r\n * @param {Number} tx2\r\n * @param {Number} ty2\r\n **/\r\nexport function append(\r\n  a2: number,\r\n  b2: number,\r\n  c2: number,\r\n  d2: number,\r\n  tx2: number,\r\n  ty2: number,\r\n) {\r\n  const change = a2 !== 1 || b2 !== 0 || c2 !== 0 || d2 !== 1;\r\n  const translate = tx2 !== 0 || ty2 !== 0;\r\n  if (!change && !translate) {\r\n    return;\r\n  }\r\n  if (hasInitialState) {\r\n    hasInitialState = false;\r\n    a = a2;\r\n    b = b2;\r\n    c = c2;\r\n    d = d2;\r\n    tx = tx2;\r\n    ty = ty2;\r\n    return;\r\n  }\r\n  const a1 = a;\r\n  const b1 = b;\r\n  const c1 = c;\r\n  const d1 = d;\r\n  if (change) {\r\n    a = a1 * a2 + c1 * b2;\r\n    b = b1 * a2 + d1 * b2;\r\n    c = a1 * c2 + c1 * d2;\r\n    d = b1 * c2 + d1 * d2;\r\n  }\r\n  if (translate) {\r\n    tx = a1 * tx2 + c1 * ty2 + tx;\r\n    ty = b1 * tx2 + d1 * ty2 + ty;\r\n  }\r\n}\r\n\r\n/**\r\n * Generates matrix properties from the specified display object transform properties, and appends them to this matrix.\r\n * For example, you can use this to generate a matrix representing the transformations of a display object:\r\n *\r\n * \treset();\r\n * \tappendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);\r\n * \tvar matrix = toArray()\r\n *\r\n * @method appendTransform\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @param {Number} scaleX\r\n * @param {Number} scaleY\r\n * @param {Number} rotation\r\n * @param {Number} skewX\r\n * @param {Number} skewY\r\n * @param {Number} regX Optional.\r\n * @param {Number} regY Optional.\r\n **/\r\nexport function appendTransform(\r\n  x: number,\r\n  y: number,\r\n  scaleX: number,\r\n  scaleY: number,\r\n  rotation: number,\r\n  skewX: number,\r\n  skewY: number,\r\n  regX: number,\r\n  regY: number,\r\n) {\r\n  if (\r\n    x === 0 &&\r\n    y === 0 &&\r\n    scaleX === 1 &&\r\n    scaleY === 1 &&\r\n    rotation === 0 &&\r\n    skewX === 0 &&\r\n    skewY === 0 &&\r\n    regX === 0 &&\r\n    regY === 0\r\n  ) {\r\n    return;\r\n  }\r\n  let cos, sin;\r\n  if (rotation % 360) {\r\n    const r = rotation * DEG_TO_RAD;\r\n    cos = Math.cos(r);\r\n    sin = Math.sin(r);\r\n  } else {\r\n    cos = 1;\r\n    sin = 0;\r\n  }\r\n\r\n  const a2 = cos * scaleX;\r\n  const b2 = sin * scaleX;\r\n  const c2 = -sin * scaleY;\r\n  const d2 = cos * scaleY;\r\n\r\n  if (skewX || skewY) {\r\n    const b1 = Math.tan(skewY * DEG_TO_RAD);\r\n    const c1 = Math.tan(skewX * DEG_TO_RAD);\r\n    append(a2 + c1 * b2, b1 * a2 + b2, c2 + c1 * d2, b1 * c2 + d2, x, y);\r\n  } else {\r\n    append(a2, b2, c2, d2, x, y);\r\n  }\r\n\r\n  if (regX || regY) {\r\n    // append the registration offset:\r\n    tx -= regX * a + regY * c;\r\n    ty -= regX * b + regY * d;\r\n    hasInitialState = false;\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}